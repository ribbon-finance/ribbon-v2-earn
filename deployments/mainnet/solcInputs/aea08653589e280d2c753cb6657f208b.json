{
  "language": "Solidity",
  "sources": {
    "contracts/interfaces/IERC20Detailed.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity =0.8.4;\n\nimport {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\ninterface IERC20Detailed is IERC20 {\n    function decimals() external view returns (uint8);\n\n    function symbol() external view returns (string calldata);\n\n    function name() external view returns (string calldata);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/IERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address recipient, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(\n        address sender,\n        address recipient,\n        uint256 amount\n    ) external returns (bool);\n\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n"
    },
    "contracts/vaults/EarnVault/RibbonEarnVault.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity =0.8.4;\n\nimport {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport {IERC20Detailed} from \"../../interfaces/IERC20Detailed.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/extensions/draft-IERC20Permit.sol\";\nimport {SafeCast} from \"@openzeppelin/contracts/utils/math/SafeCast.sol\";\nimport {\n    ReentrancyGuardUpgradeable\n} from \"@openzeppelin/contracts-upgradeable/security/ReentrancyGuardUpgradeable.sol\";\nimport {\n    OwnableUpgradeable\n} from \"@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol\";\nimport {\n    ERC20Upgradeable\n} from \"@openzeppelin/contracts-upgradeable/token/ERC20/ERC20Upgradeable.sol\";\n\nimport {\n    SafeERC20\n} from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport {IWETH} from \"../../interfaces/IWETH.sol\";\n\nimport {RibbonEarnVaultStorage} from \"../../storage/RibbonEarnVaultStorage.sol\";\nimport {Vault} from \"../../libraries/Vault.sol\";\nimport {VaultLifecycleEarn} from \"../../libraries/VaultLifecycleEarn.sol\";\nimport {ShareMath} from \"../../libraries/ShareMath.sol\";\nimport {ILiquidityGauge} from \"../../interfaces/ILiquidityGauge.sol\";\nimport {IVaultPauser} from \"../../interfaces/IVaultPauser.sol\";\n\n/**\n * Earn Vault Error Codes\n * R1: loan allocation in USD must be 0\n * R2: option allocation in USD must be 0\n * R3: invalid owner address\n * R4: msg.sender is not keeper\n * R5: msg.sender borrower weight is 0\n * R6: msg.sender is not option seller\n * R7: invalid keeper address\n * R8: invalid fee recipient address\n * R9: invalid option seller\n * R10: time lock still active\n * R11: management fee greater than 100%\n * R12: performance fee greater than 100%\n * R13: deposit cap is zero\n * R14: loan allocation is greater than 100%\n * R15: loan term length is less than a day\n * R16: option purchase frequency is zero\n * R17: option purchase frequency is greater than loan term length\n * R18: cannot use depositETH in non-eth vault\n * R19: cannot use depositETH with msg.value = 0\n * R20: vault asset is not USDC\n * R21: deposit amount is 0\n * R22: deposit amount exceeds vault cap\n * R23: deposit amount less than minimum supply\n * R24: cannot initiate withdraw on 0 shares\n * R25: a withdraw has already been initiated\n * R26: cannot complete withdraw when not initiated\n * R27: cannot complete withdraw when round not closed yet\n * R28: withdraw amount in complete withdraw is zero\n * R29: cannot redeem zero shares\n * R30: cannot redeem more shares than available\n * R31: cannot instantly withdraw zero\n * R32: cannot withdraw in current round\n * R33: exceeding amount withdrawable instantly\n * R34: purchasing option to early since last purchase  * R35: vault asset not recoverable\n * R36: vault share not recoverable\n * R37: recipient cannot be vault\n * R38: transfer failed  * R39: premature roll to next round\n * R40: array length mismatch\n * R41: invalid token name\n * R42: invalid token symbol\n * R43: invalid vault asset\n * R44: invalid vault minimum supply\n * R45: deposit cap must be higher than minimum supply\n * R46: next loan term length must be 0\n * R47: next option purchase frequency must be 0\n * R48: current loan term length must be >= 1 day\n * R49: current option purchase freq must be < loan term length\n * R50: loan pct + option pct == total PCT\n * R51: invalid pending option seller\n */\n\n/**\n * UPGRADEABILITY: Since we use the upgradeable proxy pattern, we must observe\n * the inheritance chain closely.\n * Any changes/appends in storage variable needs to happen in RibbonEarnVaultStorage.\n * RibbonEarnVault should not inherit from any other contract aside from RibbonVault, RibbonEarnVaultStorage\n */\ncontract RibbonEarnVault is\n    ReentrancyGuardUpgradeable,\n    OwnableUpgradeable,\n    ERC20Upgradeable,\n    RibbonEarnVaultStorage\n{\n    using SafeERC20 for IERC20;\n    using ShareMath for Vault.DepositReceipt;\n\n    // *IMPORTANT* NO NEW STORAGE VARIABLES SHOULD BE ADDED HERE\n    // This is to prevent storage collisions. All storage variables should be appended to RibbonEarnVaultStorage.\n    // Read this documentation to learn more:\n    // https://docs.openzeppelin.com/upgrades-plugins/1.x/writing-upgradeable#modifying-your-contracts\n\n    /************************************************\n     *  IMMUTABLES & CONSTANTS\n     ***********************************************/\n\n    /// @notice USDC 0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48\n    address public constant USDC = 0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48;\n\n    uint32 public constant TOTAL_PCT = 1000000; // Equals 100%\n\n    /************************************************\n     *  EVENTS\n     ***********************************************/\n\n    event Deposit(address indexed account, uint256 amount, uint256 round);\n\n    event InitiateWithdraw(\n        address indexed account,\n        uint256 shares,\n        uint256 round\n    );\n\n    event Redeem(address indexed account, uint256 share, uint256 round);\n\n    event ManagementFeeSet(uint256 managementFee, uint256 newManagementFee);\n\n    event PerformanceFeeSet(uint256 performanceFee, uint256 newPerformanceFee);\n\n    event CapSet(uint256 oldCap, uint256 newCap);\n\n    event BorrowerBasketUpdated(address[] borrowers, uint128[] borrowerWeights);\n\n    event CommitBorrowerBasket(uint256 totalBorrowerWeight);\n\n    event OptionSellerSet(address oldOptionSeller, address newOptionSeller);\n\n    event NewAllocationSet(\n        uint256 oldLoanAllocation,\n        uint256 oldOptionAllocation,\n        uint256 newLoanAllocation,\n        uint256 newOptionAllocation\n    );\n\n    event NewLoanTermLength(\n        uint256 oldLoanTermLength,\n        uint256 newLoanTermLength\n    );\n\n    event NewOptionPurchaseFrequency(\n        uint256 oldOptionPurchaseFrequency,\n        uint256 newOptionPurchaseFrequency\n    );\n\n    event Withdraw(address indexed account, uint256 amount, uint256 shares);\n\n    event CollectVaultFees(\n        uint256 performanceFee,\n        uint256 vaultFee,\n        uint256 round,\n        address indexed feeRecipient\n    );\n\n    event OpenLoan(uint256 amount, address indexed borrower);\n\n    event CloseLoan(uint256 amount, uint256 yield, address indexed borrower);\n\n    event PurchaseOption(uint256 premium, address indexed seller);\n\n    event PayOptionYield(\n        uint256 yield,\n        uint256 netYield,\n        address indexed seller\n    );\n\n    event InstantWithdraw(\n        address indexed account,\n        uint256 amount,\n        uint256 round\n    );\n\n    /************************************************\n     *  STRUCTS\n     ***********************************************/\n\n    /**\n     * @notice Initialization parameters for the vault.\n     * @param _owner is the owner of the vault with critical permissions\n     * @param _feeRecipient is the address to recieve vault performance and management fees\n     * @param _borrowers is the addresses of the basket of borrowing entities (EX: Wintermute, GSR, Alameda, Genesis)\n     * @param _borrowerWeights is the borrow weight of the addresses\n     * @param _optionSeller is the address of the entity that we will be buying options from (EX: Orbit)\n     * @param _managementFee is the management fee pct.\n     * @param _performanceFee is the perfomance fee pct.\n     * @param _tokenName is the name of the token\n     * @param _tokenSymbol is the symbol of the token\n     */\n    struct InitParams {\n        address _owner;\n        address _keeper;\n        address[] _borrowers;\n        uint128[] _borrowerWeights;\n        address _optionSeller;\n        address _feeRecipient;\n        uint256 _managementFee;\n        uint256 _performanceFee;\n        string _tokenName;\n        string _tokenSymbol;\n    }\n\n    /************************************************\n     *  CONSTRUCTOR & INITIALIZATION\n     ***********************************************/\n\n    /**\n     * @notice Initializes the OptionVault contract with storage variables.\n     * @param _initParams is the struct with vault initialization parameters\n     * @param _vaultParams is the struct with vault general data\n     * @param _allocationState is the struct with vault loan/option allocation data\n     */\n    function initialize(\n        InitParams calldata _initParams,\n        Vault.VaultParams calldata _vaultParams,\n        Vault.AllocationState calldata _allocationState\n    ) external initializer {\n        require(_initParams._owner != address(0), \"R3\");\n\n        VaultLifecycleEarn.verifyInitializerParams(\n            _initParams._keeper,\n            _initParams._feeRecipient,\n            _initParams._optionSeller,\n            _initParams._managementFee,\n            _initParams._performanceFee,\n            _initParams._tokenName,\n            _initParams._tokenSymbol,\n            _vaultParams,\n            _allocationState,\n            TOTAL_PCT\n        );\n\n        __ReentrancyGuard_init();\n        __ERC20_init(_initParams._tokenName, _initParams._tokenSymbol);\n        __Ownable_init();\n        transferOwnership(_initParams._owner);\n\n        keeper = _initParams._keeper;\n\n        feeRecipient = _initParams._feeRecipient;\n        optionSeller = _initParams._optionSeller;\n        performanceFee = _initParams._performanceFee;\n        managementFee =\n            (_initParams._managementFee * Vault.FEE_MULTIPLIER) /\n            ((365 days * Vault.FEE_MULTIPLIER) /\n                _allocationState.currentLoanTermLength);\n        vaultParams = _vaultParams;\n        allocationState = _allocationState;\n\n        _updateBorrowerBasket(\n            _initParams._borrowers,\n            _initParams._borrowerWeights\n        );\n\n        uint256 assetBalance =\n            IERC20(vaultParams.asset).balanceOf(address(this));\n        ShareMath.assertUint104(assetBalance);\n        vaultState.lastLockedAmount = uint104(assetBalance);\n\n        vaultState.round = 1;\n    }\n\n    /**\n     * @dev Throws if called by any account other than the keeper.\n     */\n    modifier onlyKeeper() {\n        require(msg.sender == keeper, \"R4\");\n        _;\n    }\n\n    /**\n     * @dev Throws if called by any account other than the borrower.\n     */\n    modifier onlyBorrower() {\n        require(borrowerWeights[msg.sender].borrowerWeight > 0, \"R5\");\n        _;\n    }\n\n    /**\n     * @dev Throws if called by any account other than the option seller.\n     */\n    modifier onlyOptionSeller() {\n        require(msg.sender == optionSeller, \"R6\");\n        _;\n    }\n\n    /************************************************\n     *  SETTERS\n     ***********************************************/\n\n    /**\n     * @notice Sets the new keeper\n     * @param newKeeper is the address of the new keeper\n     */\n    function setNewKeeper(address newKeeper) external onlyOwner {\n        require(newKeeper != address(0), \"R7\");\n        keeper = newKeeper;\n    }\n\n    /**\n     * @notice Sets the new fee recipient\n     * @param newFeeRecipient is the address of the new fee recipient\n     */\n    function setFeeRecipient(address newFeeRecipient) external onlyOwner {\n        require(newFeeRecipient != address(0), \"R8\");\n        feeRecipient = newFeeRecipient;\n    }\n\n    /**\n     * @notice Updates the basket of borrowers (this overrides current pending update to basket)\n     * @param borrowers is the array of borrowers to update\n     * @param borrowerWeights is the array of corresponding borrow weights for the borrower\n     */\n    function updateBorrowerBasket(\n        address[] calldata borrowers,\n        uint128[] calldata borrowerWeights\n    ) external onlyOwner {\n        _updateBorrowerBasket(borrowers, borrowerWeights);\n        lastBorrowerBasketChange = block.timestamp;\n    }\n\n    /**\n     * @notice Sets the new option seller\n     * @param newOptionSeller is the address of the new option seller\n     */\n    function setOptionSeller(address newOptionSeller) external onlyOwner {\n        require(newOptionSeller != address(0), \"R9\");\n        emit OptionSellerSet(optionSeller, newOptionSeller);\n        pendingOptionSeller = newOptionSeller;\n        lastOptionSellerChange = block.timestamp;\n    }\n\n    /**\n     * @notice Commits the option seller\n     */\n    function commitOptionSeller() external onlyOwner {\n        require(pendingOptionSeller != address(0), \"R51\");\n\n        require(block.timestamp >= (lastOptionSellerChange + 3 days), \"R10\");\n        optionSeller = pendingOptionSeller;\n        pendingOptionSeller = address(0);\n    }\n\n    /**\n     * @notice Sets the management fee for the vault\n     * @param newManagementFee is the management fee (6 decimals). ex: 2 * 10 ** 6 = 2%\n     */\n    function setManagementFee(uint256 newManagementFee) external onlyOwner {\n        require(newManagementFee < 100 * Vault.FEE_MULTIPLIER, \"R11\");\n\n        // We are dividing annualized management fee by loanTermLength\n        uint256 tmpManagementFee =\n            (newManagementFee * Vault.FEE_MULTIPLIER) /\n                ((365 days * Vault.FEE_MULTIPLIER) /\n                    allocationState.currentLoanTermLength);\n\n        emit ManagementFeeSet(managementFee, tmpManagementFee);\n\n        managementFee = tmpManagementFee;\n    }\n\n    /**\n     * @notice Sets the performance fee for the vault\n     * @param newPerformanceFee is the performance fee (6 decimals). ex: 20 * 10 ** 6 = 20%\n     */\n    function setPerformanceFee(uint256 newPerformanceFee) external onlyOwner {\n        require(newPerformanceFee < 100 * Vault.FEE_MULTIPLIER, \"R12\");\n\n        emit PerformanceFeeSet(performanceFee, newPerformanceFee);\n\n        performanceFee = newPerformanceFee;\n    }\n\n    /**\n     * @notice Sets a new cap for deposits\n     * @param newCap is the new cap for deposits\n     */\n    function setCap(uint256 newCap) external onlyOwner {\n        require(newCap > 0, \"R13\");\n        ShareMath.assertUint104(newCap);\n        emit CapSet(vaultParams.cap, newCap);\n        vaultParams.cap = uint104(newCap);\n    }\n\n    /**\n     * @notice Sets new loan and option allocation percentage\n     * @dev Can be called by admin\n     * @param _loanAllocationPCT new allocation for loan\n     * @param _optionAllocationPCT new allocation for option\n     */\n    function setAllocationPCT(\n        uint32 _loanAllocationPCT,\n        uint32 _optionAllocationPCT\n    ) external onlyOwner {\n        require(_loanAllocationPCT + _optionAllocationPCT <= TOTAL_PCT, \"R14\");\n\n        emit NewAllocationSet(\n            uint256(allocationState.loanAllocationPCT),\n            uint256(_loanAllocationPCT),\n            uint256(allocationState.optionAllocationPCT),\n            uint256(_optionAllocationPCT)\n        );\n\n        allocationState.loanAllocationPCT = _loanAllocationPCT;\n        allocationState.optionAllocationPCT = _optionAllocationPCT;\n    }\n\n    /**\n     * @notice Sets loan term length\n     * @dev Can be called by admin\n     * @param _loanTermLength new loan term length\n     */\n    function setLoanTermLength(uint32 _loanTermLength) external onlyOwner {\n        require(_loanTermLength >= 1 days, \"R15\");\n\n        allocationState.nextLoanTermLength = _loanTermLength;\n        emit NewLoanTermLength(\n            allocationState.currentLoanTermLength,\n            _loanTermLength\n        );\n    }\n\n    /**\n     * @notice Sets option purchase frequency\n     * @dev Can be called by admin\n     * @param _optionPurchaseFreq new option purchase frequency\n     */\n    function setOptionPurchaseFrequency(uint32 _optionPurchaseFreq)\n        external\n        onlyOwner\n    {\n        require(_optionPurchaseFreq > 0, \"R16\");\n\n        require(\n            (allocationState.nextLoanTermLength == 0 &&\n                _optionPurchaseFreq <= allocationState.currentLoanTermLength) ||\n                _optionPurchaseFreq <= allocationState.nextLoanTermLength,\n            \"R17\"\n        );\n        allocationState.nextOptionPurchaseFreq = _optionPurchaseFreq;\n        emit NewOptionPurchaseFrequency(\n            allocationState.currentOptionPurchaseFreq,\n            _optionPurchaseFreq\n        );\n    }\n\n    /**\n     * @notice Sets the new liquidityGauge contract for this vault\n     * @param newLiquidityGauge is the address of the new liquidityGauge contract\n     */\n    function setLiquidityGauge(address newLiquidityGauge) external onlyOwner {\n        liquidityGauge = newLiquidityGauge;\n    }\n\n    /**\n     * @notice Sets the new Vault Pauser contract for this vault\n     * @param newVaultPauser is the address of the new vaultPauser contract\n     */\n    function setVaultPauser(address newVaultPauser) external onlyOwner {\n        vaultPauser = newVaultPauser;\n    }\n\n    /************************************************\n     *  DEPOSIT & WITHDRAWALS\n     ***********************************************/\n\n    /**\n     * @notice Deposits the `asset` from msg.sender without an approve\n     * `v`, `r` and `s` must be a valid `secp256k1` signature from `owner`\n     * over the EIP712-formatted function arguments\n     * @param amount is the amount of `asset` to deposit\n     * @param deadline must be a timestamp in the future\n     * @param v is a valid signature\n     * @param r is a valid signature\n     * @param s is a valid signature\n     */\n    function depositWithPermit(\n        uint256 amount,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external nonReentrant {\n        require(vaultParams.asset == USDC, \"R20\");\n        require(amount > 0, \"R21\");\n\n        // Sign for transfer approval\n        IERC20Permit(vaultParams.asset).permit(\n            msg.sender,\n            address(this),\n            amount,\n            deadline,\n            v,\n            r,\n            s\n        );\n\n        _depositFor(amount, msg.sender);\n\n        // An approve() by the msg.sender is required beforehand\n        IERC20(vaultParams.asset).safeTransferFrom(\n            msg.sender,\n            address(this),\n            amount\n        );\n    }\n\n    /**\n     * @notice Deposits the `asset` from msg.sender.\n     * @param amount is the amount of `asset` to deposit\n     */\n    function deposit(uint256 amount) external nonReentrant {\n        require(amount > 0, \"R21\");\n\n        _depositFor(amount, msg.sender);\n\n        // An approve() by the msg.sender is required beforehand\n        IERC20(vaultParams.asset).safeTransferFrom(\n            msg.sender,\n            address(this),\n            amount\n        );\n    }\n\n    /**\n     * @notice Deposits the `asset` from msg.sender added to `creditor`'s deposit.\n     * @notice Used for vault -> vault deposits on the user's behalf\n     * @param amount is the amount of `asset` to deposit\n     * @param creditor is the address that can claim/withdraw deposited amount\n     */\n    function depositFor(uint256 amount, address creditor)\n        external\n        nonReentrant\n    {\n        require(amount > 0, \"R21\");\n        require(creditor != address(0));\n\n        _depositFor(amount, creditor);\n\n        // An approve() by the msg.sender is required beforehand\n        IERC20(vaultParams.asset).safeTransferFrom(\n            msg.sender,\n            address(this),\n            amount\n        );\n    }\n\n    /**\n     * @notice Mints the vault shares to the creditor\n     * @param amount is the amount of `asset` deposited\n     * @param creditor is the address to receieve the deposit\n     */\n    function _depositFor(uint256 amount, address creditor) private {\n        uint256 currentRound = vaultState.round;\n        uint256 totalWithDepositedAmount = totalBalance() + amount;\n\n        require(totalWithDepositedAmount <= vaultParams.cap, \"R22\");\n        require(totalWithDepositedAmount >= vaultParams.minimumSupply, \"R23\");\n\n        emit Deposit(creditor, amount, currentRound);\n\n        Vault.DepositReceipt memory depositReceipt = depositReceipts[creditor];\n\n        // If we have an unprocessed pending deposit from the previous rounds, we have to process it.\n        uint256 unredeemedShares =\n            depositReceipt.getSharesFromReceipt(\n                currentRound,\n                roundPricePerShare[depositReceipt.round],\n                vaultParams.decimals\n            );\n\n        uint256 depositAmount = amount;\n\n        // If we have a pending deposit in the current round, we add on to the pending deposit\n        if (currentRound == depositReceipt.round) {\n            uint256 newAmount = uint256(depositReceipt.amount) + amount;\n            depositAmount = newAmount;\n        }\n\n        ShareMath.assertUint104(depositAmount);\n\n        depositReceipts[creditor] = Vault.DepositReceipt({\n            round: uint16(currentRound),\n            amount: uint104(depositAmount),\n            unredeemedShares: uint128(unredeemedShares)\n        });\n\n        uint256 newTotalPending = uint256(vaultState.totalPending) + amount;\n        ShareMath.assertUint128(newTotalPending);\n\n        vaultState.totalPending = uint128(newTotalPending);\n    }\n\n    /**\n     * @notice Initiates a withdrawal that can be processed once the round completes\n     * @param numShares is the number of shares to withdraw\n     */\n    function _initiateWithdraw(uint256 numShares) internal {\n        require(numShares > 0, \"R24\");\n\n        // We do a max redeem before initiating a withdrawal\n        // But we check if they must first have unredeemed shares\n        if (\n            depositReceipts[msg.sender].amount > 0 ||\n            depositReceipts[msg.sender].unredeemedShares > 0\n        ) {\n            _redeem(0, true);\n        }\n\n        // This caches the `round` variable used in shareBalances\n        uint256 currentRound = vaultState.round;\n        Vault.Withdrawal storage withdrawal = withdrawals[msg.sender];\n\n        bool withdrawalIsSameRound = withdrawal.round == currentRound;\n\n        emit InitiateWithdraw(msg.sender, numShares, currentRound);\n\n        uint256 existingShares = uint256(withdrawal.shares);\n\n        uint256 withdrawalShares;\n        if (withdrawalIsSameRound) {\n            withdrawalShares = existingShares + numShares;\n        } else {\n            require(existingShares == 0, \"R25\");\n            withdrawalShares = numShares;\n            withdrawal.round = uint16(currentRound);\n        }\n\n        ShareMath.assertUint128(withdrawalShares);\n        withdrawal.shares = uint128(withdrawalShares);\n\n        _transfer(msg.sender, address(this), numShares);\n    }\n\n    /**\n     * @notice Completes a scheduled withdrawal from a past round. Uses finalized pps for the round\n     * @return withdrawAmount the current withdrawal amount\n     */\n    function _completeWithdraw() internal returns (uint256) {\n        Vault.Withdrawal storage withdrawal = withdrawals[msg.sender];\n\n        uint256 withdrawalShares = withdrawal.shares;\n        uint256 withdrawalRound = withdrawal.round;\n\n        // This checks if there is a withdrawal\n        require(withdrawalShares > 0, \"R26\");\n\n        require(withdrawalRound < vaultState.round, \"R27\");\n\n        // We leave the round number as non-zero to save on gas for subsequent writes\n        withdrawal.shares = 0;\n        vaultState.queuedWithdrawShares = uint128(\n            uint256(vaultState.queuedWithdrawShares) - withdrawalShares\n        );\n\n        uint256 withdrawAmount =\n            ShareMath.sharesToAsset(\n                withdrawalShares,\n                roundPricePerShare[withdrawalRound],\n                vaultParams.decimals\n            );\n\n        emit Withdraw(msg.sender, withdrawAmount, withdrawalShares);\n\n        _burn(address(this), withdrawalShares);\n\n        return withdrawAmount;\n    }\n\n    /**\n     * @notice Redeems shares that are owed to the account\n     * @param numShares is the number of shares to redeem\n     */\n    function redeem(uint256 numShares) external nonReentrant {\n        require(numShares > 0, \"R29\");\n        _redeem(numShares, false);\n    }\n\n    /**\n     * @notice Redeems the entire unredeemedShares balance that is owed to the account\n     */\n    function maxRedeem() external nonReentrant {\n        _redeem(0, true);\n    }\n\n    /**\n     * @notice Redeems shares that are owed to the account\n     * @param numShares is the number of shares to redeem, could be 0 when isMax=true\n     * @param isMax is flag for when callers do a max redemption\n     */\n    function _redeem(uint256 numShares, bool isMax) internal {\n        Vault.DepositReceipt memory depositReceipt =\n            depositReceipts[msg.sender];\n\n        // This handles the null case when depositReceipt.round = 0\n        // Because we start with round = 1 at `initialize`\n        uint256 currentRound = vaultState.round;\n\n        uint256 unredeemedShares =\n            depositReceipt.getSharesFromReceipt(\n                currentRound,\n                roundPricePerShare[depositReceipt.round],\n                vaultParams.decimals\n            );\n\n        numShares = isMax ? unredeemedShares : numShares;\n        if (numShares == 0) {\n            return;\n        }\n        require(numShares <= unredeemedShares, \"R30\");\n\n        // If we have a depositReceipt on the same round, BUT we have some unredeemed shares\n        // we debit from the unredeemedShares, but leave the amount field intact\n        // If the round has past, with no new deposits, we just zero it out for new deposits.\n        if (depositReceipt.round < currentRound) {\n            depositReceipts[msg.sender].amount = 0;\n        }\n\n        ShareMath.assertUint128(numShares);\n        depositReceipts[msg.sender].unredeemedShares = uint128(\n            unredeemedShares - numShares\n        );\n\n        emit Redeem(msg.sender, numShares, depositReceipt.round);\n\n        _transfer(address(this), msg.sender, numShares);\n    }\n\n    /**\n     * @notice Withdraws the assets on the vault using the outstanding `DepositReceipt.amount`\n     * @param amount is the amount to withdraw\n     */\n    function withdrawInstantly(uint256 amount) external nonReentrant {\n        Vault.DepositReceipt storage depositReceipt =\n            depositReceipts[msg.sender];\n\n        uint256 currentRound = vaultState.round;\n        require(amount > 0, \"R31\");\n        require(depositReceipt.round == currentRound, \"R32\");\n\n        uint256 receiptAmount = depositReceipt.amount;\n        require(receiptAmount >= amount, \"R33\");\n\n        // Subtraction underflow checks already ensure it is smaller than uint104\n        depositReceipt.amount = uint104(receiptAmount - amount);\n        vaultState.totalPending = uint128(\n            uint256(vaultState.totalPending) - amount\n        );\n\n        emit InstantWithdraw(msg.sender, amount, currentRound);\n\n        IERC20(vaultParams.asset).safeTransfer(msg.sender, amount);\n    }\n\n    /**\n     * @notice Initiates a withdrawal that can be processed once the round completes\n     * @param numShares is the number of shares to withdraw\n     */\n    function initiateWithdraw(uint256 numShares) external nonReentrant {\n        _initiateWithdraw(numShares);\n        currentQueuedWithdrawShares = currentQueuedWithdrawShares + numShares;\n    }\n\n    /**\n     * @notice Completes a scheduled withdrawal from a past round. Uses finalized pps for the round\n     */\n    function completeWithdraw() external nonReentrant {\n        uint256 withdrawAmount = _completeWithdraw();\n\n        require(withdrawAmount > 0, \"R28\");\n        lastQueuedWithdrawAmount = uint128(\n            uint256(lastQueuedWithdrawAmount) - withdrawAmount\n        );\n        IERC20(vaultParams.asset).safeTransfer(msg.sender, withdrawAmount);\n    }\n\n    /************************************************\n     *  VAULT OPERATIONS\n     ***********************************************/\n\n    /**\n     * @notice Stakes a users vault shares\n     * @param numShares is the number of shares to stake\n     */\n    function stake(uint256 numShares) external nonReentrant {\n        address _liquidityGauge = liquidityGauge;\n        require(_liquidityGauge != address(0)); // Removed revert msgs due to contract size limit\n        require(numShares > 0);\n        uint256 heldByAccount = balanceOf(msg.sender);\n        if (heldByAccount < numShares) {\n            _redeem(numShares - heldByAccount, false);\n        }\n        _transfer(msg.sender, address(this), numShares);\n        _approve(address(this), _liquidityGauge, numShares);\n        ILiquidityGauge(_liquidityGauge).deposit(numShares, msg.sender, false);\n    }\n\n    /**\n     * @notice Rolls the vault's funds into a new short position.\n     */\n    function rollToNextRound() external onlyKeeper nonReentrant {\n        vaultState.lastLockedAmount = uint104(vaultState.lockedAmount);\n\n        (uint256 lockedBalance, uint256 queuedWithdrawAmount) =\n            _rollToNextRound();\n\n        lastQueuedWithdrawAmount = queuedWithdrawAmount;\n\n        uint256 newQueuedWithdrawShares =\n            uint256(vaultState.queuedWithdrawShares) +\n                currentQueuedWithdrawShares;\n\n        ShareMath.assertUint128(newQueuedWithdrawShares);\n        vaultState.queuedWithdrawShares = uint128(newQueuedWithdrawShares);\n\n        currentQueuedWithdrawShares = 0;\n\n        ShareMath.assertUint104(lockedBalance);\n\n        vaultState.lockedAmount = uint104(lockedBalance);\n        vaultState.optionsBoughtInRound = 0;\n        vaultState.amtFundsReturned = 0;\n\n        uint256 loanAllocation = allocationState.loanAllocation;\n\n        for (uint256 i = 0; i < borrowers.length; i++) {\n            // Amount to lending = total USD loan allocation * weight of current borrower / total weight of all borrowers\n            uint256 amtToLendToBorrower =\n                (loanAllocation *\n                    borrowerWeights[borrowers[i]].borrowerWeight) /\n                    totalBorrowerWeight;\n\n            if (amtToLendToBorrower == 0) {\n                continue;\n            }\n\n            // Lend funds to borrower\n            IERC20(vaultParams.asset).safeTransfer(\n                borrowers[i],\n                amtToLendToBorrower\n            );\n\n            emit OpenLoan(amtToLendToBorrower, borrowers[i]);\n        }\n    }\n\n    /**\n     * @notice Buys the option by transferring premiums to option seller\n     */\n    function buyOption() external onlyKeeper {\n        require(\n            vaultState.optionsBoughtInRound == 0 ||\n                block.timestamp >=\n                uint256(vaultState.lastOptionPurchaseTime) +\n                    allocationState.currentOptionPurchaseFreq,\n            \"R34\"\n        );\n\n        uint256 optionAllocation =\n            allocationState.optionAllocation /\n                (uint256(allocationState.currentLoanTermLength) /\n                    allocationState.currentOptionPurchaseFreq);\n\n        vaultState.optionsBoughtInRound += uint128(optionAllocation);\n        vaultState.lastOptionPurchaseTime = uint64(block.timestamp);\n\n        IERC20(vaultParams.asset).safeTransfer(optionSeller, optionAllocation);\n\n        emit PurchaseOption(optionAllocation, optionSeller);\n    }\n\n    /**\n     * @notice Pays option yield if option is ITM\n     * `v`, `r` and `s` must be a valid `secp256k1` signature from `owner`\n     * over the EIP712-formatted function arguments\n     * @param amount is the amount of yield to pay\n     * @param deadline must be a timestamp in the future\n     * @param v is a valid signature\n     * @param r is a valid signature\n     * @param s is a valid signature\n     */\n    function payOptionYield(\n        uint256 amount,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external onlyOptionSeller {\n        // Sign for transfer approval\n        IERC20Permit(vaultParams.asset).permit(\n            msg.sender,\n            address(this),\n            amount,\n            deadline,\n            v,\n            r,\n            s\n        );\n\n        // Pay option yields to contract\n        _payOptionYield(amount);\n    }\n\n    /**\n     * @notice Pays option yield if option is ITM\n     * @param amount is the amount of yield to pay\n     */\n    function payOptionYield(uint256 amount) external onlyOptionSeller {\n        // Pay option yields to contract\n        _payOptionYield(amount);\n    }\n\n    /**\n     * @notice Return lend funds\n     * `v`, `r` and `s` must be a valid `secp256k1` signature from `owner`\n     * over the EIP712-formatted function arguments\n     * @param amount is the amount to return (principal + interest)\n     * @param deadline must be a timestamp in the future\n     * @param v is a valid signature\n     * @param r is a valid signature\n     * @param s is a valid signature\n     */\n    function returnLentFunds(\n        uint256 amount,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external onlyBorrower {\n        // Sign for transfer approval\n        IERC20Permit(vaultParams.asset).permit(\n            msg.sender,\n            address(this),\n            amount,\n            deadline,\n            v,\n            r,\n            s\n        );\n\n        // Return lent funds\n        _returnLentFunds(amount);\n    }\n\n    /**\n     * @notice Return lend funds\n     * @param amount is the amount to return (principal + interest)\n     */\n    function returnLentFunds(uint256 amount) external onlyBorrower {\n        // Return lent funds\n        _returnLentFunds(amount);\n    }\n\n    /**\n     * @notice Recovery function that returns an ERC20 token to the recipient\n     * @param token is the ERC20 token to recover from the vault\n     * @param recipient is the recipient of the recovered tokens\n     */\n    function recoverTokens(address token, address recipient)\n        external\n        onlyOwner\n    {\n        require(token != vaultParams.asset, \"R35\");\n        require(token != address(this), \"R36\");\n        require(recipient != address(this), \"R37\");\n\n        IERC20(token).safeTransfer(\n            recipient,\n            IERC20(token).balanceOf(address(this))\n        );\n    }\n\n    /**\n     * @notice pause a user's vault position\n     */\n    function pausePosition() external {\n        address _vaultPauserAddress = vaultPauser;\n        require(_vaultPauserAddress != address(0)); // Removed revert msgs due to contract size limit\n        _redeem(0, true);\n        uint256 heldByAccount = balanceOf(msg.sender);\n        _approve(msg.sender, _vaultPauserAddress, heldByAccount);\n        IVaultPauser(_vaultPauserAddress).pausePosition(\n            msg.sender,\n            heldByAccount\n        );\n    }\n\n    /**\n     * @notice Helper function that performs most administrative tasks\n     * such as minting new shares, getting vault fees, etc.\n     * @return lockedBalance is the new balance used to calculate next option purchase size or collateral size\n     * @return queuedWithdrawAmount is the new queued withdraw amount for this round\n     */\n    function _rollToNextRound()\n        internal\n        returns (uint256 lockedBalance, uint256 queuedWithdrawAmount)\n    {\n        require(\n            block.timestamp >=\n                uint256(vaultState.lastEpochTime) +\n                    allocationState.currentLoanTermLength,\n            \"R39\"\n        );\n\n        address recipient = feeRecipient;\n        uint256 mintShares;\n        uint256 performanceFeeInAsset;\n        uint256 totalVaultFee;\n        {\n            uint256 newPricePerShare;\n            (\n                lockedBalance,\n                queuedWithdrawAmount,\n                newPricePerShare,\n                mintShares,\n                performanceFeeInAsset,\n                totalVaultFee\n            ) = VaultLifecycleEarn.rollover(\n                vaultState,\n                VaultLifecycleEarn.RolloverParams(\n                    vaultParams.decimals,\n                    IERC20(vaultParams.asset).balanceOf(address(this)),\n                    totalSupply(),\n                    lastQueuedWithdrawAmount,\n                    performanceFee,\n                    managementFee,\n                    currentQueuedWithdrawShares\n                )\n            );\n\n            // Finalize the pricePerShare at the end of the round\n            uint256 currentRound = vaultState.round;\n            roundPricePerShare[currentRound] = newPricePerShare;\n\n            emit CollectVaultFees(\n                performanceFeeInAsset,\n                totalVaultFee,\n                currentRound,\n                recipient\n            );\n\n            vaultState.totalPending = 0;\n            vaultState.round = uint16(currentRound + 1);\n            vaultState.lastEpochTime = uint64(\n                block.timestamp - (block.timestamp % (24 hours)) + (8 hours)\n            );\n        }\n\n        _mint(address(this), mintShares);\n\n        if (totalVaultFee > 0) {\n            IERC20(vaultParams.asset).safeTransfer(recipient, totalVaultFee);\n        }\n\n        _updateAllocationState(lockedBalance);\n        _commitBorrowerBasket();\n\n        return (lockedBalance, queuedWithdrawAmount);\n    }\n\n    /**\n     * @notice Helper function that transfers funds from option\n     * seller\n     * @param amount is the amount of yield to pay\n     */\n    function _payOptionYield(uint256 amount) internal {\n        IERC20(vaultParams.asset).safeTransferFrom(\n            msg.sender,\n            address(this),\n            amount\n        );\n\n        uint256 optionAllocation =\n            allocationState.optionAllocation /\n                (uint256(allocationState.currentLoanTermLength) /\n                    allocationState.currentOptionPurchaseFreq);\n\n        emit PayOptionYield(\n            amount,\n            amount > optionAllocation ? amount - optionAllocation : 0,\n            msg.sender\n        );\n    }\n\n    function _returnLentFunds(uint256 amount) internal {\n        IERC20(vaultParams.asset).safeTransferFrom(\n            msg.sender,\n            address(this),\n            amount\n        );\n\n        uint256 loanAllocation = allocationState.loanAllocation;\n\n        vaultState.amtFundsReturned += amount;\n\n        emit CloseLoan(\n            amount,\n            amount > loanAllocation ? amount - loanAllocation : 0,\n            msg.sender\n        );\n    }\n\n    /**\n     * @notice Helper function that updates allocation state\n     * such as loan term length, option purchase frequency, loan / option\n     * allocation split, etc.\n     * @param lockedBalance is the locked balance for newest epoch\n     */\n    function _updateAllocationState(uint256 lockedBalance) internal {\n        Vault.AllocationState memory _allocationState = allocationState;\n\n        // Set next loan term length\n        if (_allocationState.nextLoanTermLength != 0) {\n            uint256 tmpManagementFee = managementFee;\n            managementFee =\n                (tmpManagementFee * _allocationState.nextLoanTermLength) /\n                _allocationState.currentLoanTermLength;\n\n            allocationState.currentLoanTermLength = _allocationState\n                .nextLoanTermLength;\n            allocationState.nextLoanTermLength = 0;\n\n            emit ManagementFeeSet(tmpManagementFee, managementFee);\n        }\n\n        // Set next option purchase frequency\n        if (_allocationState.nextOptionPurchaseFreq != 0) {\n            allocationState.currentOptionPurchaseFreq = _allocationState\n                .nextOptionPurchaseFreq;\n            allocationState.nextOptionPurchaseFreq = 0;\n        }\n\n        // Set next loan allocation from vault in USD\n        allocationState.loanAllocation =\n            (uint256(_allocationState.loanAllocationPCT) * lockedBalance) /\n            TOTAL_PCT;\n\n        // Set next option allocation from vault per purchase in USD\n        allocationState.optionAllocation =\n            (uint256(_allocationState.optionAllocationPCT) * lockedBalance) /\n            TOTAL_PCT;\n    }\n\n    /**\n     * @notice Helper function to update basket of borrowers\n     * @param pendingBorrowers is the array of borrowers to add\n     * @param pendingBorrowWeights is the array of corresponding borrow weights for the borrower\n     */\n    function _updateBorrowerBasket(\n        address[] calldata pendingBorrowers,\n        uint128[] calldata pendingBorrowWeights\n    ) internal {\n        uint256 borrowerArrLen = pendingBorrowers.length;\n\n        require(borrowerArrLen == pendingBorrowWeights.length, \"R40\");\n\n        // Set current pending changes to basket of borrowers\n        for (uint256 i = 0; i < borrowerArrLen; i++) {\n            if (pendingBorrowers[i] == address(0)) {\n                continue;\n            }\n\n            // Borrower does not exist\n            if (!borrowerWeights[pendingBorrowers[i]].exists) {\n                borrowers.push(pendingBorrowers[i]);\n                borrowerWeights[pendingBorrowers[i]].exists = true;\n            }\n\n            // Set pending borrower weight\n            borrowerWeights[pendingBorrowers[i]]\n                .pendingBorrowerWeight = pendingBorrowWeights[i];\n        }\n\n        emit BorrowerBasketUpdated(pendingBorrowers, pendingBorrowWeights);\n    }\n\n    /**\n     * @notice Helper function that commits borrower basket\n     */\n    function _commitBorrowerBasket() internal {\n        require(block.timestamp >= (lastBorrowerBasketChange + 3 days), \"R10\");\n\n        // Set current pending changes to basket of borrowers\n        for (uint256 i = 0; i < borrowers.length; i++) {\n            uint128 borrowWeight = borrowerWeights[borrowers[i]].borrowerWeight;\n            uint128 pendingBorrowWeight =\n                borrowerWeights[borrowers[i]].pendingBorrowerWeight;\n            // Set borrower weight to pending borrower weight\n            if (borrowWeight != pendingBorrowWeight) {\n                borrowerWeights[borrowers[i]]\n                    .borrowerWeight = pendingBorrowWeight;\n                // Update total borrowing weight\n                totalBorrowerWeight += pendingBorrowWeight;\n                totalBorrowerWeight -= borrowWeight;\n            }\n        }\n\n        emit CommitBorrowerBasket(totalBorrowerWeight);\n    }\n\n    /************************************************\n     *  GETTERS\n     ***********************************************/\n\n    /**\n     * @notice Returns the asset balance held on the vault for the account\n     * @param account is the address to lookup balance for\n     * @return the amount of `asset` custodied by the vault for the user\n     */\n    function accountVaultBalance(address account)\n        external\n        view\n        returns (uint256)\n    {\n        uint256 _decimals = vaultParams.decimals;\n        uint256 assetPerShare =\n            ShareMath.pricePerShare(\n                totalSupply(),\n                totalBalance(),\n                vaultState.totalPending,\n                _decimals\n            );\n        return\n            ShareMath.sharesToAsset(shares(account), assetPerShare, _decimals);\n    }\n\n    /**\n     * @notice Getter for returning the account's share balance including unredeemed shares\n     * @param account is the account to lookup share balance for\n     * @return the share balance\n     */\n    function shares(address account) public view returns (uint256) {\n        (uint256 heldByAccount, uint256 heldByVault) = shareBalances(account);\n        return heldByAccount + heldByVault;\n    }\n\n    /**\n     * @notice Getter for returning the account's share balance split between account and vault holdings\n     * @param account is the account to lookup share balance for\n     * @return heldByAccount is the shares held by account\n     * @return heldByVault is the shares held on the vault (unredeemedShares)\n     */\n    function shareBalances(address account)\n        public\n        view\n        returns (uint256 heldByAccount, uint256 heldByVault)\n    {\n        Vault.DepositReceipt memory depositReceipt = depositReceipts[account];\n\n        if (depositReceipt.round < ShareMath.PLACEHOLDER_UINT) {\n            return (balanceOf(account), 0);\n        }\n\n        uint256 unredeemedShares =\n            depositReceipt.getSharesFromReceipt(\n                vaultState.round,\n                roundPricePerShare[depositReceipt.round],\n                vaultParams.decimals\n            );\n\n        return (balanceOf(account), unredeemedShares);\n    }\n\n    /**\n     * @notice The price of a unit of share denominated in the `asset`\n     */\n    function pricePerShare() external view returns (uint256) {\n        return\n            ShareMath.pricePerShare(\n                totalSupply(),\n                totalBalance(),\n                vaultState.totalPending,\n                vaultParams.decimals\n            );\n    }\n\n    /**\n     * @notice Returns the vault's total balance, including the amounts lent out\n     * @return total balance of the vault, including the amounts locked in third party protocols\n     */\n    function totalBalance() public view returns (uint256) {\n        uint256 lockedForOptionPurchases = allocationState.optionAllocation;\n\n        uint256 amtPrincipalReturned =\n            vaultState.amtFundsReturned > allocationState.loanAllocation\n                ? allocationState.loanAllocation\n                : vaultState.amtFundsReturned;\n\n        // We subtract the funds allocated towards option purchases as these are \"lost funds\"\n        // We subtract the amount of principal returned to avoid double counting in locked amount / USDC balance\n        return\n            uint256(vaultState.lockedAmount) +\n            IERC20(vaultParams.asset).balanceOf(address(this)) -\n            lockedForOptionPurchases -\n            amtPrincipalReturned;\n    }\n\n    /**\n     * @notice Returns the token decimals\n     */\n    function decimals() public view override returns (uint8) {\n        return vaultParams.decimals;\n    }\n\n    function cap() external view returns (uint256) {\n        return vaultParams.cap;\n    }\n\n    function totalPending() external view returns (uint256) {\n        return vaultState.totalPending;\n    }\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/extensions/draft-IERC20Permit.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC20 Permit extension allowing approvals to be made via signatures, as defined in\n * https://eips.ethereum.org/EIPS/eip-2612[EIP-2612].\n *\n * Adds the {permit} method, which can be used to change an account's ERC20 allowance (see {IERC20-allowance}) by\n * presenting a message signed by the account. By not relying on {IERC20-approve}, the token holder account doesn't\n * need to send a transaction, and thus is not required to hold Ether at all.\n */\ninterface IERC20Permit {\n    /**\n     * @dev Sets `value` as the allowance of `spender` over ``owner``'s tokens,\n     * given ``owner``'s signed approval.\n     *\n     * IMPORTANT: The same issues {IERC20-approve} has related to transaction\n     * ordering also apply here.\n     *\n     * Emits an {Approval} event.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     * - `deadline` must be a timestamp in the future.\n     * - `v`, `r` and `s` must be a valid `secp256k1` signature from `owner`\n     * over the EIP712-formatted function arguments.\n     * - the signature must use ``owner``'s current nonce (see {nonces}).\n     *\n     * For more information on the signature format, see the\n     * https://eips.ethereum.org/EIPS/eip-2612#specification[relevant EIP\n     * section].\n     */\n    function permit(\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external;\n\n    /**\n     * @dev Returns the current nonce for `owner`. This value must be\n     * included whenever a signature is generated for {permit}.\n     *\n     * Every successful call to {permit} increases ``owner``'s nonce by one. This\n     * prevents a signature from being used multiple times.\n     */\n    function nonces(address owner) external view returns (uint256);\n\n    /**\n     * @dev Returns the domain separator used in the encoding of the signature for {permit}, as defined by {EIP712}.\n     */\n    // solhint-disable-next-line func-name-mixedcase\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\n}\n"
    },
    "@openzeppelin/contracts/utils/math/SafeCast.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Wrappers over Solidity's uintXX/intXX casting operators with added overflow\n * checks.\n *\n * Downcasting from uint256/int256 in Solidity does not revert on overflow. This can\n * easily result in undesired exploitation or bugs, since developers usually\n * assume that overflows raise errors. `SafeCast` restores this intuition by\n * reverting the transaction when such an operation overflows.\n *\n * Using this library instead of the unchecked operations eliminates an entire\n * class of bugs, so it's recommended to use it always.\n *\n * Can be combined with {SafeMath} and {SignedSafeMath} to extend it to smaller types, by performing\n * all math on `uint256` and `int256` and then downcasting.\n */\nlibrary SafeCast {\n    /**\n     * @dev Returns the downcasted uint224 from uint256, reverting on\n     * overflow (when the input is greater than largest uint224).\n     *\n     * Counterpart to Solidity's `uint224` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 224 bits\n     */\n    function toUint224(uint256 value) internal pure returns (uint224) {\n        require(value <= type(uint224).max, \"SafeCast: value doesn't fit in 224 bits\");\n        return uint224(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint128 from uint256, reverting on\n     * overflow (when the input is greater than largest uint128).\n     *\n     * Counterpart to Solidity's `uint128` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 128 bits\n     */\n    function toUint128(uint256 value) internal pure returns (uint128) {\n        require(value <= type(uint128).max, \"SafeCast: value doesn't fit in 128 bits\");\n        return uint128(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint96 from uint256, reverting on\n     * overflow (when the input is greater than largest uint96).\n     *\n     * Counterpart to Solidity's `uint96` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 96 bits\n     */\n    function toUint96(uint256 value) internal pure returns (uint96) {\n        require(value <= type(uint96).max, \"SafeCast: value doesn't fit in 96 bits\");\n        return uint96(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint64 from uint256, reverting on\n     * overflow (when the input is greater than largest uint64).\n     *\n     * Counterpart to Solidity's `uint64` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 64 bits\n     */\n    function toUint64(uint256 value) internal pure returns (uint64) {\n        require(value <= type(uint64).max, \"SafeCast: value doesn't fit in 64 bits\");\n        return uint64(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint32 from uint256, reverting on\n     * overflow (when the input is greater than largest uint32).\n     *\n     * Counterpart to Solidity's `uint32` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 32 bits\n     */\n    function toUint32(uint256 value) internal pure returns (uint32) {\n        require(value <= type(uint32).max, \"SafeCast: value doesn't fit in 32 bits\");\n        return uint32(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint16 from uint256, reverting on\n     * overflow (when the input is greater than largest uint16).\n     *\n     * Counterpart to Solidity's `uint16` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 16 bits\n     */\n    function toUint16(uint256 value) internal pure returns (uint16) {\n        require(value <= type(uint16).max, \"SafeCast: value doesn't fit in 16 bits\");\n        return uint16(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint8 from uint256, reverting on\n     * overflow (when the input is greater than largest uint8).\n     *\n     * Counterpart to Solidity's `uint8` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 8 bits.\n     */\n    function toUint8(uint256 value) internal pure returns (uint8) {\n        require(value <= type(uint8).max, \"SafeCast: value doesn't fit in 8 bits\");\n        return uint8(value);\n    }\n\n    /**\n     * @dev Converts a signed int256 into an unsigned uint256.\n     *\n     * Requirements:\n     *\n     * - input must be greater than or equal to 0.\n     */\n    function toUint256(int256 value) internal pure returns (uint256) {\n        require(value >= 0, \"SafeCast: value must be positive\");\n        return uint256(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int128 from int256, reverting on\n     * overflow (when the input is less than smallest int128 or\n     * greater than largest int128).\n     *\n     * Counterpart to Solidity's `int128` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 128 bits\n     *\n     * _Available since v3.1._\n     */\n    function toInt128(int256 value) internal pure returns (int128) {\n        require(value >= type(int128).min && value <= type(int128).max, \"SafeCast: value doesn't fit in 128 bits\");\n        return int128(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int64 from int256, reverting on\n     * overflow (when the input is less than smallest int64 or\n     * greater than largest int64).\n     *\n     * Counterpart to Solidity's `int64` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 64 bits\n     *\n     * _Available since v3.1._\n     */\n    function toInt64(int256 value) internal pure returns (int64) {\n        require(value >= type(int64).min && value <= type(int64).max, \"SafeCast: value doesn't fit in 64 bits\");\n        return int64(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int32 from int256, reverting on\n     * overflow (when the input is less than smallest int32 or\n     * greater than largest int32).\n     *\n     * Counterpart to Solidity's `int32` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 32 bits\n     *\n     * _Available since v3.1._\n     */\n    function toInt32(int256 value) internal pure returns (int32) {\n        require(value >= type(int32).min && value <= type(int32).max, \"SafeCast: value doesn't fit in 32 bits\");\n        return int32(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int16 from int256, reverting on\n     * overflow (when the input is less than smallest int16 or\n     * greater than largest int16).\n     *\n     * Counterpart to Solidity's `int16` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 16 bits\n     *\n     * _Available since v3.1._\n     */\n    function toInt16(int256 value) internal pure returns (int16) {\n        require(value >= type(int16).min && value <= type(int16).max, \"SafeCast: value doesn't fit in 16 bits\");\n        return int16(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int8 from int256, reverting on\n     * overflow (when the input is less than smallest int8 or\n     * greater than largest int8).\n     *\n     * Counterpart to Solidity's `int8` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 8 bits.\n     *\n     * _Available since v3.1._\n     */\n    function toInt8(int256 value) internal pure returns (int8) {\n        require(value >= type(int8).min && value <= type(int8).max, \"SafeCast: value doesn't fit in 8 bits\");\n        return int8(value);\n    }\n\n    /**\n     * @dev Converts an unsigned uint256 into a signed int256.\n     *\n     * Requirements:\n     *\n     * - input must be less than or equal to maxInt256.\n     */\n    function toInt256(uint256 value) internal pure returns (int256) {\n        // Note: Unsafe cast below is okay because `type(int256).max` is guaranteed to be positive\n        require(value <= uint256(type(int256).max), \"SafeCast: value doesn't fit in an int256\");\n        return int256(value);\n    }\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/security/ReentrancyGuardUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\nimport \"../proxy/utils/Initializable.sol\";\n\n/**\n * @dev Contract module that helps prevent reentrant calls to a function.\n *\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\n * available, which can be applied to functions to make sure there are no nested\n * (reentrant) calls to them.\n *\n * Note that because there is a single `nonReentrant` guard, functions marked as\n * `nonReentrant` may not call one another. This can be worked around by making\n * those functions `private`, and then adding `external` `nonReentrant` entry\n * points to them.\n *\n * TIP: If you would like to learn more about reentrancy and alternative ways\n * to protect against it, check out our blog post\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\n */\nabstract contract ReentrancyGuardUpgradeable is Initializable {\n    // Booleans are more expensive than uint256 or any type that takes up a full\n    // word because each write operation emits an extra SLOAD to first read the\n    // slot's contents, replace the bits taken up by the boolean, and then write\n    // back. This is the compiler's defense against contract upgrades and\n    // pointer aliasing, and it cannot be disabled.\n\n    // The values being non-zero value makes deployment a bit more expensive,\n    // but in exchange the refund on every call to nonReentrant will be lower in\n    // amount. Since refunds are capped to a percentage of the total\n    // transaction's gas, it is best to keep them low in cases like this one, to\n    // increase the likelihood of the full refund coming into effect.\n    uint256 private constant _NOT_ENTERED = 1;\n    uint256 private constant _ENTERED = 2;\n\n    uint256 private _status;\n\n    function __ReentrancyGuard_init() internal initializer {\n        __ReentrancyGuard_init_unchained();\n    }\n\n    function __ReentrancyGuard_init_unchained() internal initializer {\n        _status = _NOT_ENTERED;\n    }\n\n    /**\n     * @dev Prevents a contract from calling itself, directly or indirectly.\n     * Calling a `nonReentrant` function from another `nonReentrant`\n     * function is not supported. It is possible to prevent this from happening\n     * by making the `nonReentrant` function external, and make it call a\n     * `private` function that does the actual work.\n     */\n    modifier nonReentrant() {\n        // On the first call to nonReentrant, _notEntered will be true\n        require(_status != _ENTERED, \"ReentrancyGuard: reentrant call\");\n\n        // Any calls to nonReentrant after this point will fail\n        _status = _ENTERED;\n\n        _;\n\n        // By storing the original value once again, a refund is triggered (see\n        // https://eips.ethereum.org/EIPS/eip-2200)\n        _status = _NOT_ENTERED;\n    }\n    uint256[49] private __gap;\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport \"../utils/ContextUpgradeable.sol\";\nimport \"../proxy/utils/Initializable.sol\";\n\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * By default, the owner account will be the one that deploys the contract. This\n * can later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\nabstract contract OwnableUpgradeable is Initializable, ContextUpgradeable {\n    address private _owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the deployer as the initial owner.\n     */\n    function __Ownable_init() internal initializer {\n        __Context_init_unchained();\n        __Ownable_init_unchained();\n    }\n\n    function __Ownable_init_unchained() internal initializer {\n        _setOwner(_msgSender());\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        require(owner() == _msgSender(), \"Ownable: caller is not the owner\");\n        _;\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby removing any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        _setOwner(address(0));\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\n        _setOwner(newOwner);\n    }\n\n    function _setOwner(address newOwner) private {\n        address oldOwner = _owner;\n        _owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n    uint256[49] private __gap;\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/token/ERC20/ERC20Upgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport \"./IERC20Upgradeable.sol\";\nimport \"./extensions/IERC20MetadataUpgradeable.sol\";\nimport \"../../utils/ContextUpgradeable.sol\";\nimport \"../../proxy/utils/Initializable.sol\";\n\n/**\n * @dev Implementation of the {IERC20} interface.\n *\n * This implementation is agnostic to the way tokens are created. This means\n * that a supply mechanism has to be added in a derived contract using {_mint}.\n * For a generic mechanism see {ERC20PresetMinterPauser}.\n *\n * TIP: For a detailed writeup see our guide\n * https://forum.zeppelin.solutions/t/how-to-implement-erc20-supply-mechanisms/226[How\n * to implement supply mechanisms].\n *\n * We have followed general OpenZeppelin Contracts guidelines: functions revert\n * instead returning `false` on failure. This behavior is nonetheless\n * conventional and does not conflict with the expectations of ERC20\n * applications.\n *\n * Additionally, an {Approval} event is emitted on calls to {transferFrom}.\n * This allows applications to reconstruct the allowance for all accounts just\n * by listening to said events. Other implementations of the EIP may not emit\n * these events, as it isn't required by the specification.\n *\n * Finally, the non-standard {decreaseAllowance} and {increaseAllowance}\n * functions have been added to mitigate the well-known issues around setting\n * allowances. See {IERC20-approve}.\n */\ncontract ERC20Upgradeable is Initializable, ContextUpgradeable, IERC20Upgradeable, IERC20MetadataUpgradeable {\n    mapping(address => uint256) private _balances;\n\n    mapping(address => mapping(address => uint256)) private _allowances;\n\n    uint256 private _totalSupply;\n\n    string private _name;\n    string private _symbol;\n\n    /**\n     * @dev Sets the values for {name} and {symbol}.\n     *\n     * The default value of {decimals} is 18. To select a different value for\n     * {decimals} you should overload it.\n     *\n     * All two of these values are immutable: they can only be set once during\n     * construction.\n     */\n    function __ERC20_init(string memory name_, string memory symbol_) internal initializer {\n        __Context_init_unchained();\n        __ERC20_init_unchained(name_, symbol_);\n    }\n\n    function __ERC20_init_unchained(string memory name_, string memory symbol_) internal initializer {\n        _name = name_;\n        _symbol = symbol_;\n    }\n\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() public view virtual override returns (string memory) {\n        return _name;\n    }\n\n    /**\n     * @dev Returns the symbol of the token, usually a shorter version of the\n     * name.\n     */\n    function symbol() public view virtual override returns (string memory) {\n        return _symbol;\n    }\n\n    /**\n     * @dev Returns the number of decimals used to get its user representation.\n     * For example, if `decimals` equals `2`, a balance of `505` tokens should\n     * be displayed to a user as `5.05` (`505 / 10 ** 2`).\n     *\n     * Tokens usually opt for a value of 18, imitating the relationship between\n     * Ether and Wei. This is the value {ERC20} uses, unless this function is\n     * overridden;\n     *\n     * NOTE: This information is only used for _display_ purposes: it in\n     * no way affects any of the arithmetic of the contract, including\n     * {IERC20-balanceOf} and {IERC20-transfer}.\n     */\n    function decimals() public view virtual override returns (uint8) {\n        return 18;\n    }\n\n    /**\n     * @dev See {IERC20-totalSupply}.\n     */\n    function totalSupply() public view virtual override returns (uint256) {\n        return _totalSupply;\n    }\n\n    /**\n     * @dev See {IERC20-balanceOf}.\n     */\n    function balanceOf(address account) public view virtual override returns (uint256) {\n        return _balances[account];\n    }\n\n    /**\n     * @dev See {IERC20-transfer}.\n     *\n     * Requirements:\n     *\n     * - `recipient` cannot be the zero address.\n     * - the caller must have a balance of at least `amount`.\n     */\n    function transfer(address recipient, uint256 amount) public virtual override returns (bool) {\n        _transfer(_msgSender(), recipient, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-allowance}.\n     */\n    function allowance(address owner, address spender) public view virtual override returns (uint256) {\n        return _allowances[owner][spender];\n    }\n\n    /**\n     * @dev See {IERC20-approve}.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function approve(address spender, uint256 amount) public virtual override returns (bool) {\n        _approve(_msgSender(), spender, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-transferFrom}.\n     *\n     * Emits an {Approval} event indicating the updated allowance. This is not\n     * required by the EIP. See the note at the beginning of {ERC20}.\n     *\n     * Requirements:\n     *\n     * - `sender` and `recipient` cannot be the zero address.\n     * - `sender` must have a balance of at least `amount`.\n     * - the caller must have allowance for ``sender``'s tokens of at least\n     * `amount`.\n     */\n    function transferFrom(\n        address sender,\n        address recipient,\n        uint256 amount\n    ) public virtual override returns (bool) {\n        _transfer(sender, recipient, amount);\n\n        uint256 currentAllowance = _allowances[sender][_msgSender()];\n        require(currentAllowance >= amount, \"ERC20: transfer amount exceeds allowance\");\n        unchecked {\n            _approve(sender, _msgSender(), currentAllowance - amount);\n        }\n\n        return true;\n    }\n\n    /**\n     * @dev Atomically increases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {\n        _approve(_msgSender(), spender, _allowances[_msgSender()][spender] + addedValue);\n        return true;\n    }\n\n    /**\n     * @dev Atomically decreases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     * - `spender` must have allowance for the caller of at least\n     * `subtractedValue`.\n     */\n    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {\n        uint256 currentAllowance = _allowances[_msgSender()][spender];\n        require(currentAllowance >= subtractedValue, \"ERC20: decreased allowance below zero\");\n        unchecked {\n            _approve(_msgSender(), spender, currentAllowance - subtractedValue);\n        }\n\n        return true;\n    }\n\n    /**\n     * @dev Moves `amount` of tokens from `sender` to `recipient`.\n     *\n     * This internal function is equivalent to {transfer}, and can be used to\n     * e.g. implement automatic token fees, slashing mechanisms, etc.\n     *\n     * Emits a {Transfer} event.\n     *\n     * Requirements:\n     *\n     * - `sender` cannot be the zero address.\n     * - `recipient` cannot be the zero address.\n     * - `sender` must have a balance of at least `amount`.\n     */\n    function _transfer(\n        address sender,\n        address recipient,\n        uint256 amount\n    ) internal virtual {\n        require(sender != address(0), \"ERC20: transfer from the zero address\");\n        require(recipient != address(0), \"ERC20: transfer to the zero address\");\n\n        _beforeTokenTransfer(sender, recipient, amount);\n\n        uint256 senderBalance = _balances[sender];\n        require(senderBalance >= amount, \"ERC20: transfer amount exceeds balance\");\n        unchecked {\n            _balances[sender] = senderBalance - amount;\n        }\n        _balances[recipient] += amount;\n\n        emit Transfer(sender, recipient, amount);\n\n        _afterTokenTransfer(sender, recipient, amount);\n    }\n\n    /** @dev Creates `amount` tokens and assigns them to `account`, increasing\n     * the total supply.\n     *\n     * Emits a {Transfer} event with `from` set to the zero address.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     */\n    function _mint(address account, uint256 amount) internal virtual {\n        require(account != address(0), \"ERC20: mint to the zero address\");\n\n        _beforeTokenTransfer(address(0), account, amount);\n\n        _totalSupply += amount;\n        _balances[account] += amount;\n        emit Transfer(address(0), account, amount);\n\n        _afterTokenTransfer(address(0), account, amount);\n    }\n\n    /**\n     * @dev Destroys `amount` tokens from `account`, reducing the\n     * total supply.\n     *\n     * Emits a {Transfer} event with `to` set to the zero address.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     * - `account` must have at least `amount` tokens.\n     */\n    function _burn(address account, uint256 amount) internal virtual {\n        require(account != address(0), \"ERC20: burn from the zero address\");\n\n        _beforeTokenTransfer(account, address(0), amount);\n\n        uint256 accountBalance = _balances[account];\n        require(accountBalance >= amount, \"ERC20: burn amount exceeds balance\");\n        unchecked {\n            _balances[account] = accountBalance - amount;\n        }\n        _totalSupply -= amount;\n\n        emit Transfer(account, address(0), amount);\n\n        _afterTokenTransfer(account, address(0), amount);\n    }\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the `owner` s tokens.\n     *\n     * This internal function is equivalent to `approve`, and can be used to\n     * e.g. set automatic allowances for certain subsystems, etc.\n     *\n     * Emits an {Approval} event.\n     *\n     * Requirements:\n     *\n     * - `owner` cannot be the zero address.\n     * - `spender` cannot be the zero address.\n     */\n    function _approve(\n        address owner,\n        address spender,\n        uint256 amount\n    ) internal virtual {\n        require(owner != address(0), \"ERC20: approve from the zero address\");\n        require(spender != address(0), \"ERC20: approve to the zero address\");\n\n        _allowances[owner][spender] = amount;\n        emit Approval(owner, spender, amount);\n    }\n\n    /**\n     * @dev Hook that is called before any transfer of tokens. This includes\n     * minting and burning.\n     *\n     * Calling conditions:\n     *\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\n     * will be transferred to `to`.\n     * - when `from` is zero, `amount` tokens will be minted for `to`.\n     * - when `to` is zero, `amount` of ``from``'s tokens will be burned.\n     * - `from` and `to` are never both zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _beforeTokenTransfer(\n        address from,\n        address to,\n        uint256 amount\n    ) internal virtual {}\n\n    /**\n     * @dev Hook that is called after any transfer of tokens. This includes\n     * minting and burning.\n     *\n     * Calling conditions:\n     *\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\n     * has been transferred to `to`.\n     * - when `from` is zero, `amount` tokens have been minted for `to`.\n     * - when `to` is zero, `amount` of ``from``'s tokens have been burned.\n     * - `from` and `to` are never both zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _afterTokenTransfer(\n        address from,\n        address to,\n        uint256 amount\n    ) internal virtual {}\n    uint256[45] private __gap;\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport \"../IERC20.sol\";\nimport \"../../../utils/Address.sol\";\n\n/**\n * @title SafeERC20\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\n * contract returns false). Tokens that return no value (and instead revert or\n * throw on failure) are also supported, non-reverting calls are assumed to be\n * successful.\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\n */\nlibrary SafeERC20 {\n    using Address for address;\n\n    function safeTransfer(\n        IERC20 token,\n        address to,\n        uint256 value\n    ) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\n    }\n\n    function safeTransferFrom(\n        IERC20 token,\n        address from,\n        address to,\n        uint256 value\n    ) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\n    }\n\n    /**\n     * @dev Deprecated. This function has issues similar to the ones found in\n     * {IERC20-approve}, and its usage is discouraged.\n     *\n     * Whenever possible, use {safeIncreaseAllowance} and\n     * {safeDecreaseAllowance} instead.\n     */\n    function safeApprove(\n        IERC20 token,\n        address spender,\n        uint256 value\n    ) internal {\n        // safeApprove should only be called when setting an initial allowance,\n        // or when resetting it to zero. To increase and decrease it, use\n        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\n        require(\n            (value == 0) || (token.allowance(address(this), spender) == 0),\n            \"SafeERC20: approve from non-zero to non-zero allowance\"\n        );\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\n    }\n\n    function safeIncreaseAllowance(\n        IERC20 token,\n        address spender,\n        uint256 value\n    ) internal {\n        uint256 newAllowance = token.allowance(address(this), spender) + value;\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n    }\n\n    function safeDecreaseAllowance(\n        IERC20 token,\n        address spender,\n        uint256 value\n    ) internal {\n        unchecked {\n            uint256 oldAllowance = token.allowance(address(this), spender);\n            require(oldAllowance >= value, \"SafeERC20: decreased allowance below zero\");\n            uint256 newAllowance = oldAllowance - value;\n            _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n        }\n    }\n\n    /**\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\n     * @param token The token targeted by the call.\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     */\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\n        // we're implementing it ourselves. We use {Address.functionCall} to perform this call, which verifies that\n        // the target address contains contract code and also asserts for success in the low-level call.\n\n        bytes memory returndata = address(token).functionCall(data, \"SafeERC20: low-level call failed\");\n        if (returndata.length > 0) {\n            // Return data is optional\n            require(abi.decode(returndata, (bool)), \"SafeERC20: ERC20 operation did not succeed\");\n        }\n    }\n}\n"
    },
    "contracts/interfaces/IWETH.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity =0.8.4;\n\ninterface IWETH {\n    function deposit() external payable;\n\n    function withdraw(uint256) external;\n\n    function balanceOf(address account) external view returns (uint256);\n\n    function transfer(address recipient, uint256 amount)\n        external\n        returns (bool);\n\n    function allowance(address owner, address spender)\n        external\n        view\n        returns (uint256);\n\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    function transferFrom(\n        address sender,\n        address recipient,\n        uint256 amount\n    ) external returns (bool);\n\n    function decimals() external view returns (uint256);\n}\n"
    },
    "contracts/storage/RibbonEarnVaultStorage.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity =0.8.4;\n\nimport {Vault} from \"../libraries/Vault.sol\";\n\nabstract contract RibbonEarnVaultStorageV1 {\n    /// @notice Stores the user's pending deposit for the round\n    mapping(address => Vault.DepositReceipt) public depositReceipts;\n\n    /// @notice On every round's close, the pricePerShare value of an rTHETA token is stored\n    /// This is used to determine the number of shares to be returned\n    /// to a user with their DepositReceipt.depositAmount\n    mapping(uint256 => uint256) public roundPricePerShare;\n\n    /// @notice Stores pending user withdrawals\n    mapping(address => Vault.Withdrawal) public withdrawals;\n\n    /// @notice Vault's parameters like cap, decimals\n    Vault.VaultParams public vaultParams;\n\n    /// @notice Vault's lifecycle state like round and locked amounts\n    Vault.VaultState public vaultState;\n\n    /// @notice Vault's state of the allocation between lending and buying options\n    Vault.AllocationState public allocationState;\n\n    /// @notice Fee recipient for the performance and management fees\n    address public feeRecipient;\n\n    /// @notice role in charge of weekly vault operations such as rollToNextRound and burnRemainingOTokens\n    // no access to critical vault changes\n    address public keeper;\n\n    /// @notice borrowers is the array of borrowing addresses (EX: Wintermute, GSR, Alameda, Genesis)\n    address[] public borrowers;\n\n    /// @notice borrowerMapping is the mapping from borrower to their borrow weight. EX: {Wintermute -> 0.4, GSR -> 0.2}\n    mapping(address => Vault.BorrowerState) public borrowerWeights;\n\n    /// @notice totalBorrowerWeight is the total borrowing weight\n    uint256 public totalBorrowerWeight;\n\n    /// @notice lastBorrowerBasketChange is the last time the basket of borrowers was changed (add / remove / set)\n    uint256 public lastBorrowerBasketChange;\n\n    /// @notice optionSeller is the address of the entity that we will be buying options from (EX: Orbit)\n    address public optionSeller;\n\n    /// @notice pendingOptionSeller is the pending address of the entity that we will be buying options from (EX: Orbit)\n    address public pendingOptionSeller;\n\n    /// @notice lastOptionSellerChange is the last time option seller was set\n    uint256 public lastOptionSellerChange;\n\n    /// @notice Performance fee charged on premiums earned in rollToNextRound. Only charged when there is no loss.\n    uint256 public performanceFee;\n\n    /// @notice Management fee charged on entire AUM in rollToNextRound. Only charged when there is no loss.\n    uint256 public managementFee;\n\n    /// @notice Amount locked for scheduled withdrawals last week;\n    uint256 public lastQueuedWithdrawAmount;\n\n    /// @notice Queued withdraw shares for the current round\n    uint256 public currentQueuedWithdrawShares;\n\n    /// @notice Vault Pauser Contract for the vault\n    address public vaultPauser;\n\n    /// @notice LiquidityGauge contract for the vault\n    address public liquidityGauge;\n}\n\n// We are following Compound's method of upgrading new contract implementations\n// When we need to add new storage variables, we create a new version of RibbonEarnVaultStorage\n// e.g. RibbonEarnVaultStorage<versionNumber>, so finally it would look like\n// contract RibbonEarnVaultStorage is RibbonEarnVaultStorageV1, RibbonEarnVaultStorageV2\nabstract contract RibbonEarnVaultStorage is RibbonEarnVaultStorageV1 {\n\n}\n"
    },
    "contracts/libraries/Vault.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity =0.8.4;\n\nlibrary Vault {\n    /************************************************\n     *  IMMUTABLES & CONSTANTS\n     ***********************************************/\n\n    // Fees are 6-decimal places. For example: 20 * 10**6 = 20%\n    uint256 internal constant FEE_MULTIPLIER = 10**6;\n\n    // Yield is scaled by 100 (10 ** 2) for PCT.\n    uint256 internal constant YIELD_MULTIPLIER = 10**2;\n\n    // Placeholder uint value to prevent cold writes\n    uint256 internal constant PLACEHOLDER_UINT = 1;\n\n    struct VaultParams {\n        // Token decimals for vault shares\n        uint8 decimals;\n        // Asset used in vault\n        address asset;\n        // Minimum supply of the vault shares issued, for ETH it's 10**10\n        uint56 minimumSupply;\n        // Vault cap\n        uint104 cap;\n    }\n\n    struct AllocationState {\n        // Next Loan Term Length\n        uint32 nextLoanTermLength;\n        // Next Option Purchase Frequency\n        uint32 nextOptionPurchaseFreq;\n        // Current Loan Term Length\n        uint32 currentLoanTermLength;\n        // Current Option Purchase Frequency\n        uint32 currentOptionPurchaseFreq;\n        // Current Loan Allocation Percent\n        uint32 loanAllocationPCT;\n        // Current Option Purchase Allocation Percent\n        uint32 optionAllocationPCT;\n        // Loan Allocation in USD\n        uint256 loanAllocation;\n        // Option Purchase Allocation across all purchases\n        uint256 optionAllocation;\n    }\n\n    struct VaultState {\n        // 32 byte slot 1\n        //  Current round number. `round` represents the number of `period`s elapsed.\n        uint16 round;\n        // Amount that is currently locked for the strategy\n        uint104 lockedAmount;\n        // Amount that was locked for the strategy in the previous round\n        // used for calculating performance fee deduction\n        uint104 lastLockedAmount;\n        // 32 byte slot 2\n        // Stores the total tally of how much of `asset` there is\n        // to be used to mint rTHETA tokens\n        uint128 totalPending;\n        // Total amount of queued withdrawal shares from previous rounds (doesn't include the current round)\n        uint128 queuedWithdrawShares;\n        // Last Loan Allocation Date\n        uint64 lastEpochTime;\n        // Last Option Purchase Date\n        uint64 lastOptionPurchaseTime;\n        // Amount of options bought in current round\n        uint128 optionsBoughtInRound;\n        // Amount of funds returned this round\n        uint256 amtFundsReturned;\n    }\n\n    struct DepositReceipt {\n        // Maximum of 65535 rounds. Assuming 1 round is 7 days, maximum is 1256 years.\n        uint16 round;\n        // Deposit amount, max 20,282,409,603,651 or 20 trillion ETH deposit\n        uint104 amount;\n        // Unredeemed shares balance\n        uint128 unredeemedShares;\n    }\n\n    struct Withdrawal {\n        // Maximum of 65535 rounds. Assuming 1 round is 7 days, maximum is 1256 years.\n        uint16 round;\n        // Number of shares withdrawn\n        uint128 shares;\n    }\n\n    /**\n     * @param borrowerWeight is the borrow weight of the borrower\n     * @param pendingBorrowerWeight is the pending borrow weight\n     * @param exists is whether the borrower has already been added\n     */\n    struct BorrowerState {\n        // Borrower exists\n        bool exists;\n        // Borrower weight\n        uint128 borrowerWeight;\n        // Borrower weight\n        uint128 pendingBorrowerWeight;\n    }\n}\n"
    },
    "contracts/libraries/VaultLifecycleEarn.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity =0.8.4;\n\nimport {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport {Vault} from \"./Vault.sol\";\nimport {ShareMath} from \"./ShareMath.sol\";\n\nimport {IERC20Detailed} from \"../interfaces/IERC20Detailed.sol\";\nimport {SupportsNonCompliantERC20} from \"./SupportsNonCompliantERC20.sol\";\n\nlibrary VaultLifecycleEarn {\n    using SupportsNonCompliantERC20 for IERC20;\n\n    /**\n     * @param decimals is the decimals of the asset\n     * @param totalBalance is the vaults total balance of the asset\n     * @param currentShareSupply is the supply of the shares invoked with totalSupply()\n     * @param lastQueuedWithdrawAmount is the total amount queued for withdrawals\n     * @param performanceFee is the perf fee percent to charge on premiums\n     * @param managementFee is the management fee percent to charge on the AUM\n     * @param currentQueuedWithdrawShares is amount of queued withdrawals from the current round\n     */\n    struct RolloverParams {\n        uint256 decimals;\n        uint256 totalBalance;\n        uint256 currentShareSupply;\n        uint256 lastQueuedWithdrawAmount;\n        uint256 performanceFee;\n        uint256 managementFee;\n        uint256 currentQueuedWithdrawShares;\n    }\n\n    /**\n     * @notice Calculate the shares to mint, new price per share, and\n      amount of funds to re-allocate as collateral for the new round\n     * @param vaultState is the storage variable vaultState passed from RibbonVault\n     * @param params is the rollover parameters passed to compute the next state\n     * @return newLockedAmount is the amount of funds to allocate for the new round\n     * @return queuedWithdrawAmount is the amount of funds set aside for withdrawal\n     * @return newPricePerShare is the price per share of the new round\n     * @return mintShares is the amount of shares to mint from deposits\n     * @return performanceFeeInAsset is the performance fee charged by vault\n     * @return totalVaultFee is the total amount of fee charged by vault\n     */\n    function rollover(\n        Vault.VaultState storage vaultState,\n        RolloverParams calldata params\n    )\n        external\n        view\n        returns (\n            uint256 newLockedAmount,\n            uint256 queuedWithdrawAmount,\n            uint256 newPricePerShare,\n            uint256 mintShares,\n            uint256 performanceFeeInAsset,\n            uint256 totalVaultFee\n        )\n    {\n        uint256 currentBalance = params.totalBalance;\n        uint256 pendingAmount = vaultState.totalPending;\n        // Total amount of queued withdrawal shares from previous rounds (doesn't include the current round)\n        uint256 lastQueuedWithdrawShares = vaultState.queuedWithdrawShares;\n\n        // Deduct older queued withdraws so we don't charge fees on them\n        uint256 balanceForVaultFees =\n            currentBalance - params.lastQueuedWithdrawAmount;\n\n        {\n            (performanceFeeInAsset, , totalVaultFee) = VaultLifecycleEarn\n                .getVaultFees(\n                balanceForVaultFees,\n                vaultState.lastLockedAmount,\n                vaultState.totalPending,\n                params.performanceFee,\n                params.managementFee\n            );\n        }\n\n        // Take into account the fee\n        // so we can calculate the newPricePerShare\n        currentBalance = currentBalance - totalVaultFee;\n\n        {\n            newPricePerShare = ShareMath.pricePerShare(\n                params.currentShareSupply - lastQueuedWithdrawShares,\n                currentBalance - params.lastQueuedWithdrawAmount,\n                pendingAmount,\n                params.decimals\n            );\n\n            queuedWithdrawAmount =\n                params.lastQueuedWithdrawAmount +\n                ShareMath.sharesToAsset(\n                    params.currentQueuedWithdrawShares,\n                    newPricePerShare,\n                    params.decimals\n                );\n\n            // After closing the short, if the options expire in-the-money\n            // vault pricePerShare would go down because vault's asset balance decreased.\n            // This ensures that the newly-minted shares do not take on the loss.\n            mintShares = ShareMath.assetToShares(\n                pendingAmount,\n                newPricePerShare,\n                params.decimals\n            );\n        }\n\n        return (\n            currentBalance - queuedWithdrawAmount, // new locked balance subtracts the queued withdrawals\n            queuedWithdrawAmount,\n            newPricePerShare,\n            mintShares,\n            performanceFeeInAsset,\n            totalVaultFee\n        );\n    }\n\n    /**\n     * @notice Calculates the performance and management fee for this week's round\n     * @param currentBalance is the balance of funds held on the vault after closing short\n     * @param lastLockedAmount is the amount of funds locked from the previous round\n     * @param pendingAmount is the pending deposit amount\n     * @param performanceFeePercent is the performance fee pct.\n     * @param managementFeePercent is the management fee pct.\n     * @return performanceFeeInAsset is the performance fee\n     * @return managementFeeInAsset is the management fee\n     * @return vaultFee is the total fees\n     */\n    function getVaultFees(\n        uint256 currentBalance,\n        uint256 lastLockedAmount,\n        uint256 pendingAmount,\n        uint256 performanceFeePercent,\n        uint256 managementFeePercent\n    )\n        internal\n        pure\n        returns (\n            uint256 performanceFeeInAsset,\n            uint256 managementFeeInAsset,\n            uint256 vaultFee\n        )\n    {\n        // At the first round, currentBalance=0, pendingAmount>0\n        // so we just do not charge anything on the first round\n        uint256 lockedBalanceSansPending =\n            currentBalance > pendingAmount ? currentBalance - pendingAmount : 0;\n\n        uint256 _performanceFeeInAsset;\n        uint256 _managementFeeInAsset;\n        uint256 _vaultFee;\n\n        // Take performance fee and management fee ONLY if difference between\n        // last week and this week's vault deposits, taking into account pending\n        // deposits and withdrawals, is positive. If it is negative, last week's\n        // option expired ITM past breakeven, and the vault took a loss so we\n        // do not collect performance fee for last week\n        if (lockedBalanceSansPending > lastLockedAmount) {\n            _performanceFeeInAsset = performanceFeePercent > 0\n                ? ((lockedBalanceSansPending - lastLockedAmount) *\n                    performanceFeePercent) / (100 * Vault.FEE_MULTIPLIER)\n                : 0;\n            _managementFeeInAsset = managementFeePercent > 0\n                ? (lockedBalanceSansPending * managementFeePercent) /\n                    (100 * Vault.FEE_MULTIPLIER)\n                : 0;\n\n            _vaultFee = _performanceFeeInAsset + _managementFeeInAsset;\n        }\n\n        return (_performanceFeeInAsset, _managementFeeInAsset, _vaultFee);\n    }\n\n    /**\n     * @notice Verify the constructor params satisfy requirements\n     * @param feeRecipient is the address to recieve vault performance and management fees\n     * @param optionSeller is the address of the entity that we will be buying options from (EX: Orbit)\n     * @param performanceFee is the perfomance fee pct.\n     * @param tokenName is the name of the token\n     * @param tokenSymbol is the symbol of the token\n     * @param _vaultParams is the struct with vault general data\n     * @param _allocationState is the struct with vault loan/option allocation data\n     */\n    function verifyInitializerParams(\n        address keeper,\n        address feeRecipient,\n        address optionSeller,\n        uint256 performanceFee,\n        uint256 managementFee,\n        string calldata tokenName,\n        string calldata tokenSymbol,\n        Vault.VaultParams calldata _vaultParams,\n        Vault.AllocationState calldata _allocationState,\n        uint256 totalPCT\n    ) external pure {\n        require(keeper != address(0), \"R7\");\n        require(feeRecipient != address(0), \"R8\");\n        require(optionSeller != address(0), \"R9\");\n\n        require(performanceFee < 100 * Vault.FEE_MULTIPLIER, \"R12\");\n        require(managementFee < 100 * Vault.FEE_MULTIPLIER, \"R11\");\n        require(bytes(tokenName).length > 0, \"R41\");\n        require(bytes(tokenSymbol).length > 0, \"R42\");\n\n        require(_vaultParams.asset != address(0), \"R43\");\n        require(_vaultParams.minimumSupply > 0, \"R44\");\n        require(_vaultParams.cap > 0, \"R13\");\n        require(_vaultParams.cap > _vaultParams.minimumSupply, \"R45\");\n\n        require(_allocationState.nextLoanTermLength == 0, \"R46\");\n        require(_allocationState.nextOptionPurchaseFreq == 0, \"R47\");\n        require(_allocationState.currentLoanTermLength >= 1 days, \"R48\");\n        require(\n            _allocationState.currentOptionPurchaseFreq > 0 &&\n                _allocationState.currentOptionPurchaseFreq <=\n                _allocationState.currentLoanTermLength,\n            \"R49\"\n        );\n        require(\n            uint256(_allocationState.loanAllocationPCT) +\n                _allocationState.optionAllocationPCT <=\n                totalPCT,\n            \"R50\"\n        );\n        require(_allocationState.loanAllocation == 0, \"R1\");\n        require(_allocationState.optionAllocation == 0, \"R2\");\n    }\n}\n"
    },
    "contracts/libraries/ShareMath.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity =0.8.4;\n\nimport {Vault} from \"./Vault.sol\";\n\nlibrary ShareMath {\n    uint256 internal constant PLACEHOLDER_UINT = 1;\n\n    function assetToShares(\n        uint256 assetAmount,\n        uint256 assetPerShare,\n        uint256 decimals\n    ) internal pure returns (uint256) {\n        // If this throws, it means that vault's roundPricePerShare[currentRound] has not been set yet\n        // which should never happen.\n        // Has to be larger than 1 because `1` is used in `initRoundPricePerShares` to prevent cold writes.\n        require(assetPerShare > PLACEHOLDER_UINT, \"Invalid assetPerShare\");\n\n        return (assetAmount * (10**decimals)) / assetPerShare;\n    }\n\n    function sharesToAsset(\n        uint256 shares,\n        uint256 assetPerShare,\n        uint256 decimals\n    ) internal pure returns (uint256) {\n        // If this throws, it means that vault's roundPricePerShare[currentRound] has not been set yet\n        // which should never happen.\n        // Has to be larger than 1 because `1` is used in `initRoundPricePerShares` to prevent cold writes.\n        require(assetPerShare > PLACEHOLDER_UINT, \"Invalid assetPerShare\");\n\n        return (shares * assetPerShare) / (10**decimals);\n    }\n\n    /**\n     * @notice Returns the shares unredeemed by the user given their DepositReceipt\n     * @param depositReceipt is the user's deposit receipt\n     * @param currentRound is the `round` stored on the vault\n     * @param assetPerShare is the price in asset per share\n     * @param decimals is the number of decimals the asset/shares use\n     * @return unredeemedShares is the user's virtual balance of shares that are owed\n     */\n    function getSharesFromReceipt(\n        Vault.DepositReceipt memory depositReceipt,\n        uint256 currentRound,\n        uint256 assetPerShare,\n        uint256 decimals\n    ) internal pure returns (uint256 unredeemedShares) {\n        if (depositReceipt.round > 0 && depositReceipt.round < currentRound) {\n            uint256 sharesFromRound =\n                assetToShares(depositReceipt.amount, assetPerShare, decimals);\n\n            return uint256(depositReceipt.unredeemedShares) + sharesFromRound;\n        }\n        return depositReceipt.unredeemedShares;\n    }\n\n    function pricePerShare(\n        uint256 totalSupply,\n        uint256 totalBalance,\n        uint256 pendingAmount,\n        uint256 decimals\n    ) internal pure returns (uint256) {\n        uint256 singleShare = 10**decimals;\n        return\n            totalSupply > 0\n                ? (singleShare * (totalBalance - pendingAmount)) / totalSupply\n                : singleShare;\n    }\n\n    /************************************************\n     *  HELPERS\n     ***********************************************/\n\n    function assertUint104(uint256 num) internal pure {\n        require(num <= type(uint104).max, \"Overflow uint104\");\n    }\n\n    function assertUint128(uint256 num) internal pure {\n        require(num <= type(uint128).max, \"Overflow uint128\");\n    }\n}\n"
    },
    "contracts/interfaces/ILiquidityGauge.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity =0.8.4;\n\ninterface ILiquidityGauge {\n    function balanceOf(address) external view returns (uint256);\n\n    function deposit(\n        uint256 _value,\n        address _addr,\n        bool _claim_rewards\n    ) external;\n\n    function withdraw(uint256 _value) external;\n}\n"
    },
    "contracts/interfaces/IVaultPauser.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity =0.8.4;\n\ninterface IVaultPauser {\n    /// @notice pause vault position of an account with max amount\n    /// @param _account the address of user\n    /// @param _amount amount of shares\n    function pausePosition(address _account, uint256 _amount) external;\n\n    /// @notice resume vault position of an account with max amount\n    /// @param _vaultAddress the address of vault\n    function resumePosition(address _vaultAddress) external;\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\n/**\n * @dev This is a base contract to aid in writing upgradeable contracts, or any kind of contract that will be deployed\n * behind a proxy. Since a proxied contract can't have a constructor, it's common to move constructor logic to an\n * external initializer function, usually called `initialize`. It then becomes necessary to protect this initializer\n * function so it can only be called once. The {initializer} modifier provided by this contract will have this effect.\n *\n * TIP: To avoid leaving the proxy in an uninitialized state, the initializer function should be called as early as\n * possible by providing the encoded function call as the `_data` argument to {ERC1967Proxy-constructor}.\n *\n * CAUTION: When used with inheritance, manual care must be taken to not invoke a parent initializer twice, or to ensure\n * that all initializers are idempotent. This is not verified automatically as constructors are by Solidity.\n */\nabstract contract Initializable {\n    /**\n     * @dev Indicates that the contract has been initialized.\n     */\n    bool private _initialized;\n\n    /**\n     * @dev Indicates that the contract is in the process of being initialized.\n     */\n    bool private _initializing;\n\n    /**\n     * @dev Modifier to protect an initializer function from being invoked twice.\n     */\n    modifier initializer() {\n        require(_initializing || !_initialized, \"Initializable: contract is already initialized\");\n\n        bool isTopLevelCall = !_initializing;\n        if (isTopLevelCall) {\n            _initializing = true;\n            _initialized = true;\n        }\n\n        _;\n\n        if (isTopLevelCall) {\n            _initializing = false;\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/utils/ContextUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\nimport \"../proxy/utils/Initializable.sol\";\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract ContextUpgradeable is Initializable {\n    function __Context_init() internal initializer {\n        __Context_init_unchained();\n    }\n\n    function __Context_init_unchained() internal initializer {\n    }\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n    uint256[50] private __gap;\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20Upgradeable {\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address recipient, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(\n        address sender,\n        address recipient,\n        uint256 amount\n    ) external returns (bool);\n\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/token/ERC20/extensions/IERC20MetadataUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport \"../IERC20Upgradeable.sol\";\n\n/**\n * @dev Interface for the optional metadata functions from the ERC20 standard.\n *\n * _Available since v4.1._\n */\ninterface IERC20MetadataUpgradeable is IERC20Upgradeable {\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() external view returns (string memory);\n\n    /**\n     * @dev Returns the symbol of the token.\n     */\n    function symbol() external view returns (string memory);\n\n    /**\n     * @dev Returns the decimals places of the token.\n     */\n    function decimals() external view returns (uint8);\n}\n"
    },
    "@openzeppelin/contracts/utils/Address.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary Address {\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following\n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     * ====\n     */\n    function isContract(address account) internal view returns (bool) {\n        // This method relies on extcodesize, which returns 0 for contracts in\n        // construction, since the code is only stored at the end of the\n        // constructor execution.\n\n        uint256 size;\n        assembly {\n            size := extcodesize(account)\n        }\n        return size > 0;\n    }\n\n    /**\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\n\n        (bool success, ) = recipient.call{value: amount}(\"\");\n        require(success, \"Address: unable to send value, recipient may have reverted\");\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain `call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason, it is bubbled up by this\n     * function (like regular Solidity function calls).\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCall(target, data, \"Address: low-level call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n     * `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(address(this).balance >= value, \"Address: insufficient balance for call\");\n        require(isContract(target), \"Address: call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, \"Address: low-level static call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        require(isContract(target), \"Address: static call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionDelegateCall(target, data, \"Address: low-level delegate call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(isContract(target), \"Address: delegate call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Tool to verifies that a low level call was successful, and revert if it wasn't, either by bubbling the\n     * revert reason using the provided one.\n     *\n     * _Available since v4.3._\n     */\n    function verifyCallResult(\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal pure returns (bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            // Look for revert reason and bubble it up if present\n            if (returndata.length > 0) {\n                // The easiest way to bubble the revert reason is using memory via assembly\n\n                assembly {\n                    let returndata_size := mload(returndata)\n                    revert(add(32, returndata), returndata_size)\n                }\n            } else {\n                revert(errorMessage);\n            }\n        }\n    }\n}\n"
    },
    "contracts/libraries/SupportsNonCompliantERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity =0.8.4;\nimport {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport {\n    SafeERC20\n} from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\n\n/**\n * This library supports ERC20s that have quirks in their behavior.\n * One such ERC20 is USDT, which requires allowance to be 0 before calling approve.\n * We plan to update this library with ERC20s that display such idiosyncratic behavior.\n */\nlibrary SupportsNonCompliantERC20 {\n    address private constant USDT = 0xdAC17F958D2ee523a2206206994597C13D831ec7;\n\n    function safeApproveNonCompliant(\n        IERC20 token,\n        address spender,\n        uint256 amount\n    ) internal {\n        if (address(token) == USDT) {\n            SafeERC20.safeApprove(token, spender, 0);\n        }\n        SafeERC20.safeApprove(token, spender, amount);\n    }\n}\n"
    },
    "contracts/vaults/VaultPauser/RibbonVaultPauser.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity =0.8.4;\nimport {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport {\n    SafeERC20\n} from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport {Ownable} from \"@openzeppelin/contracts/access/Ownable.sol\";\nimport {IVaultPauser} from \"../../interfaces/IVaultPauser.sol\";\nimport {Vault} from \"../../libraries/Vault.sol\";\nimport {IRibbonEarnVault} from \"../../interfaces/IRibbonEarnVault.sol\";\nimport {IWETH} from \"../../interfaces/IWETH.sol\";\nimport {ShareMath} from \"../../libraries/ShareMath.sol\";\n\ncontract RibbonVaultPauser is Ownable, IVaultPauser {\n    using SafeERC20 for IERC20;\n\n    /************************************************\n     *  NON UPGRADEABLE STORAGE\n     ***********************************************/\n\n    /// @notice Stores all the vault's paused positions\n    struct PauseReceipt {\n        uint16 round;\n        uint128 shares;\n    }\n\n    mapping(address => mapping(address => PauseReceipt)) public pausedPositions;\n    mapping(address => bool) private registeredVaults;\n\n    /************************************************\n     *  IMMUTABLES & CONSTANTS\n     ***********************************************/\n    /// @notice WETH9 0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2\n    address public immutable WETH;\n    address public immutable STETH;\n    address public immutable STETH_VAULT;\n\n    address public keeper;\n    /************************************************\n     *  EVENTS\n     ***********************************************/\n\n    event Pause(\n        address indexed account,\n        address indexed vaultAddress,\n        uint256 share,\n        uint256 round\n    );\n\n    event Resume(\n        address indexed account,\n        address indexed vaultAddress,\n        uint256 withdrawAmount\n    );\n\n    event ProcessWithdrawal(address indexed vaultAddress, uint256 round);\n\n    /************************************************\n     *  CONSTRUCTOR & INITIALIZATION\n     ***********************************************/\n\n    /**\n     * @notice Initializes the contract with immutable variables\n     */\n    constructor(\n        address _keeper,\n        address _weth,\n        address _steth,\n        address _steth_vault\n    ) {\n        require(_keeper != address(0), \"!_keeper\");\n        require(_weth != address(0), \"!_weth\");\n        require(_steth != address(0), \"!_steth\");\n        require(_steth_vault != address(0), \"!_steth_vault\");\n\n        keeper = _keeper;\n        WETH = _weth;\n        STETH = _steth;\n        STETH_VAULT = _steth_vault;\n    }\n\n    /**\n     * @dev Throws if called by any account other than the keeper.\n     */\n    modifier onlyKeeper() {\n        require(msg.sender == keeper, \"!keeper\");\n        _;\n    }\n\n    /************************************************\n     *  GETTERS\n     ***********************************************/\n\n    function getPausePosition(address _vaultAddress, address _userAddress)\n        external\n        view\n        returns (PauseReceipt memory)\n    {\n        return pausedPositions[_vaultAddress][_userAddress];\n    }\n\n    /************************************************\n     *  SETTERS\n     ***********************************************/\n\n    /**\n     * @notice Sets the new keeper\n     * @param _newKeeper is the address of the new keeper\n     */\n    function setNewKeeper(address _newKeeper) external onlyOwner {\n        require(_newKeeper != address(0), \"!newKeeper\");\n        keeper = _newKeeper;\n    }\n\n    /**\n     * @notice add vault into registered vaults\n     * @param _vaultAddress is the address of the new vault to be registered\n     */\n    function addVault(address _vaultAddress) external onlyOwner {\n        registeredVaults[_vaultAddress] = true;\n    }\n\n    /************************************************\n     *  VAULT OPERATIONS\n     ***********************************************/\n\n    /**\n     * @notice pause position from vault by redeem all the shares from vault to Pauser\n     * @param _account user's address\n     * @param _amount the amount of shares\n     */\n    function pausePosition(address _account, uint256 _amount)\n        external\n        override\n    {\n        address currentVaultAddress = msg.sender;\n        IRibbonEarnVault currentVault = IRibbonEarnVault(currentVaultAddress);\n\n        // check if vault is registered\n        require(\n            registeredVaults[currentVaultAddress],\n            \"Vault is not registered\"\n        );\n\n        PauseReceipt storage pausedPosition =\n            pausedPositions[currentVaultAddress][_account];\n\n        // check if position is paused\n        require(\n            pausedPosition.shares == 0 && pausedPosition.round == 0,\n            \"Position is paused\"\n        );\n\n        uint16 round = currentVault.vaultState().round;\n\n        require(_amount < type(uint128).max, \"_amount overflow\");\n\n        pausedPosition.round = round;\n        pausedPosition.shares = uint128(_amount);\n\n        emit Pause(_account, currentVaultAddress, _amount, round);\n\n        // transfer from user to pauser\n        IERC20(currentVaultAddress).safeTransferFrom(\n            _account,\n            address(this),\n            _amount\n        );\n\n        currentVault.initiateWithdraw(_amount);\n    }\n\n    /**\n     * @notice resume user's position into vault by making a deposit\n     * @param _vaultAddress vault's address\n     */\n    function resumePosition(address _vaultAddress) external override {\n        IRibbonEarnVault currentVault = IRibbonEarnVault(_vaultAddress);\n\n        // check if vault is registered\n        require(registeredVaults[_vaultAddress], \"Vault is not registered\");\n\n        // get params and round\n        Vault.VaultParams memory currentParams = currentVault.vaultParams();\n        uint256 round = currentVault.vaultState().round;\n\n        PauseReceipt storage pauseReceipt =\n            pausedPositions[_vaultAddress][msg.sender];\n        uint256 pauseReceiptRound = pauseReceipt.round;\n\n        // check if roun is closed before resuming position\n        require(pauseReceiptRound < round, \"Round not closed yet\");\n        uint256 totalWithdrawAmount =\n            ShareMath.sharesToAsset(\n                pauseReceipt.shares,\n                currentVault.roundPricePerShare(pauseReceiptRound),\n                currentParams.decimals\n            );\n\n        // delete position once transfer (revert to zero)\n        delete pausedPositions[_vaultAddress][msg.sender];\n\n        // stETH transfers suffer from an off-by-1 error\n        // since we received STETH , we shall deposit using STETH instead of ETH\n        if (_vaultAddress == STETH_VAULT) {\n            totalWithdrawAmount = totalWithdrawAmount - 3;\n\n            emit Resume(msg.sender, _vaultAddress, totalWithdrawAmount - 1);\n            IERC20(STETH).safeApprove(_vaultAddress, totalWithdrawAmount);\n            currentVault.depositYieldTokenFor(totalWithdrawAmount, msg.sender);\n        } else {\n            emit Resume(msg.sender, _vaultAddress, totalWithdrawAmount);\n\n            // if asset is ETH, we will convert it into WETH before depositing\n            if (currentParams.asset == WETH) {\n                IWETH(WETH).deposit{value: totalWithdrawAmount}();\n            }\n            IERC20(currentParams.asset).safeApprove(\n                _vaultAddress,\n                totalWithdrawAmount\n            );\n\n            currentVault.depositFor(totalWithdrawAmount, msg.sender);\n        }\n    }\n\n    /**\n     * @notice process withdrawals by completing in a batch\n     * @param _vaultAddress vault's address to be processed\n     */\n    function processWithdrawal(address _vaultAddress) external onlyKeeper {\n        IRibbonEarnVault currentVault = IRibbonEarnVault(_vaultAddress);\n        // we can only process withdrawal after closing the previous round\n        // hence round should be - 1\n        emit ProcessWithdrawal(\n            _vaultAddress,\n            currentVault.vaultState().round - 1\n        );\n        currentVault.completeWithdraw();\n    }\n\n    fallback() external payable {}\n\n    receive() external payable {}\n}\n"
    },
    "@openzeppelin/contracts/access/Ownable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport \"../utils/Context.sol\";\n\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * By default, the owner account will be the one that deploys the contract. This\n * can later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\nabstract contract Ownable is Context {\n    address private _owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the deployer as the initial owner.\n     */\n    constructor() {\n        _setOwner(_msgSender());\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        require(owner() == _msgSender(), \"Ownable: caller is not the owner\");\n        _;\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby removing any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        _setOwner(address(0));\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\n        _setOwner(newOwner);\n    }\n\n    function _setOwner(address newOwner) private {\n        address oldOwner = _owner;\n        _owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n}\n"
    },
    "contracts/interfaces/IRibbonEarnVault.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity =0.8.4;\n\nimport {Vault} from \"../libraries/Vault.sol\";\n\ninterface IRibbonEarnVault {\n    function vaultParams() external view returns (Vault.VaultParams memory);\n\n    function vaultState() external view returns (Vault.VaultState memory);\n\n    function pricePerShare() external view returns (uint256);\n\n    function roundPricePerShare(uint256) external view returns (uint256);\n\n    function depositFor(uint256 amount, address creditor) external;\n\n    function initiateWithdraw(uint256 numShares) external;\n\n    function completeWithdraw() external;\n\n    function maxRedeem() external;\n\n    function symbol() external view returns (string calldata);\n\n    function depositYieldTokenFor(uint256 amount, address creditor) external;\n}\n"
    },
    "@openzeppelin/contracts/utils/Context.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n}\n"
    },
    "contracts/tests/TestShareMath.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity =0.8.4;\n\nimport {ShareMath} from \"../libraries/ShareMath.sol\";\n\ncontract TestShareMath {\n    function assetToShares(\n        uint256 assetAmount,\n        uint256 pps,\n        uint256 decimals\n    ) external pure returns (uint256) {\n        return ShareMath.assetToShares(assetAmount, pps, decimals);\n    }\n\n    function sharesToAsset(\n        uint256 shares,\n        uint256 pps,\n        uint256 decimals\n    ) external pure returns (uint256) {\n        return ShareMath.sharesToAsset(shares, pps, decimals);\n    }\n}\n"
    },
    "contracts/tests/TestVaultLifecycleEarn.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity =0.8.4;\n\nimport {VaultLifecycleEarn} from \"../libraries/VaultLifecycleEarn.sol\";\nimport {Vault} from \"../libraries/Vault.sol\";\n\ncontract TestVaultLifecycleEarn {\n    Vault.VaultState public vaultState;\n\n    function balanceOf(address account) public view returns (uint256) {\n        if (account == address(this)) {\n            return 1 ether;\n        }\n        return 0;\n    }\n\n    function setVaultState(Vault.VaultState calldata newVaultState) public {\n        vaultState.totalPending = newVaultState.totalPending;\n        vaultState.queuedWithdrawShares = newVaultState.queuedWithdrawShares;\n    }\n\n    function rollover(VaultLifecycleEarn.RolloverParams calldata params)\n        external\n        view\n        returns (\n            uint256 newLockedAmount,\n            uint256 queuedWithdrawAmount,\n            uint256 newPricePerShare,\n            uint256 mintShares,\n            uint256 performanceFeeInAsset,\n            uint256 totalVaultFee\n        )\n    {\n        return VaultLifecycleEarn.rollover(vaultState, params);\n    }\n}\n"
    },
    "contracts/tests/MockRibbonVault.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity =0.8.4;\n\nimport {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport {Vault} from \"../libraries/Vault.sol\";\n\ncontract MockRibbonVault {\n    Vault.VaultParams public vaultParams;\n\n    function setAsset(address asset) external {\n        vaultParams.asset = asset;\n    }\n}\n"
    },
    "contracts/vendor/CustomSafeERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity =0.8.4;\nimport {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport {ERC20} from \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\n\n/**\n * @title SafeERC20\n * @dev Wrappers around ERC20 operations that throw on failure.\n * To use this library you can add a `using SafeERC20 for ERC20;` statement to your contract,\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\n */\nlibrary SafeERC20 {\n  function safeTransfer(IERC20 token, address to, uint256 value) internal {\n      require(_callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value)),\n          \"ERC20 transfer failed\");\n  }\n\n  function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {\n      require(_callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value)),\n          \"ERC20 transferFrom failed\");\n  }\n\n  function safeApprove(IERC20 token, address spender, uint256 value) internal {\n    if (_callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value))) {\n        return;\n    }\n    require(_callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, 0))\n        && _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value)),\n        \"ERC20 approve failed\");\n  }\n\n  function _callOptionalReturn(IERC20 token, bytes memory data) private returns (bool) {\n      // solhint-disable-next-line avoid-low-level-calls\n      (bool success, bytes memory returndata) = address(token).call(data);\n      if (!success) {\n          return false;\n      }\n\n      if (returndata.length >= 32) { // Return data is optional\n          return abi.decode(returndata, (bool));\n      }\n\n      // In a wierd case when return data is 1-31 bytes long - return false.\n      return returndata.length == 0;\n  }\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/ERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport \"./IERC20.sol\";\nimport \"./extensions/IERC20Metadata.sol\";\nimport \"../../utils/Context.sol\";\n\n/**\n * @dev Implementation of the {IERC20} interface.\n *\n * This implementation is agnostic to the way tokens are created. This means\n * that a supply mechanism has to be added in a derived contract using {_mint}.\n * For a generic mechanism see {ERC20PresetMinterPauser}.\n *\n * TIP: For a detailed writeup see our guide\n * https://forum.zeppelin.solutions/t/how-to-implement-erc20-supply-mechanisms/226[How\n * to implement supply mechanisms].\n *\n * We have followed general OpenZeppelin Contracts guidelines: functions revert\n * instead returning `false` on failure. This behavior is nonetheless\n * conventional and does not conflict with the expectations of ERC20\n * applications.\n *\n * Additionally, an {Approval} event is emitted on calls to {transferFrom}.\n * This allows applications to reconstruct the allowance for all accounts just\n * by listening to said events. Other implementations of the EIP may not emit\n * these events, as it isn't required by the specification.\n *\n * Finally, the non-standard {decreaseAllowance} and {increaseAllowance}\n * functions have been added to mitigate the well-known issues around setting\n * allowances. See {IERC20-approve}.\n */\ncontract ERC20 is Context, IERC20, IERC20Metadata {\n    mapping(address => uint256) private _balances;\n\n    mapping(address => mapping(address => uint256)) private _allowances;\n\n    uint256 private _totalSupply;\n\n    string private _name;\n    string private _symbol;\n\n    /**\n     * @dev Sets the values for {name} and {symbol}.\n     *\n     * The default value of {decimals} is 18. To select a different value for\n     * {decimals} you should overload it.\n     *\n     * All two of these values are immutable: they can only be set once during\n     * construction.\n     */\n    constructor(string memory name_, string memory symbol_) {\n        _name = name_;\n        _symbol = symbol_;\n    }\n\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() public view virtual override returns (string memory) {\n        return _name;\n    }\n\n    /**\n     * @dev Returns the symbol of the token, usually a shorter version of the\n     * name.\n     */\n    function symbol() public view virtual override returns (string memory) {\n        return _symbol;\n    }\n\n    /**\n     * @dev Returns the number of decimals used to get its user representation.\n     * For example, if `decimals` equals `2`, a balance of `505` tokens should\n     * be displayed to a user as `5.05` (`505 / 10 ** 2`).\n     *\n     * Tokens usually opt for a value of 18, imitating the relationship between\n     * Ether and Wei. This is the value {ERC20} uses, unless this function is\n     * overridden;\n     *\n     * NOTE: This information is only used for _display_ purposes: it in\n     * no way affects any of the arithmetic of the contract, including\n     * {IERC20-balanceOf} and {IERC20-transfer}.\n     */\n    function decimals() public view virtual override returns (uint8) {\n        return 18;\n    }\n\n    /**\n     * @dev See {IERC20-totalSupply}.\n     */\n    function totalSupply() public view virtual override returns (uint256) {\n        return _totalSupply;\n    }\n\n    /**\n     * @dev See {IERC20-balanceOf}.\n     */\n    function balanceOf(address account) public view virtual override returns (uint256) {\n        return _balances[account];\n    }\n\n    /**\n     * @dev See {IERC20-transfer}.\n     *\n     * Requirements:\n     *\n     * - `recipient` cannot be the zero address.\n     * - the caller must have a balance of at least `amount`.\n     */\n    function transfer(address recipient, uint256 amount) public virtual override returns (bool) {\n        _transfer(_msgSender(), recipient, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-allowance}.\n     */\n    function allowance(address owner, address spender) public view virtual override returns (uint256) {\n        return _allowances[owner][spender];\n    }\n\n    /**\n     * @dev See {IERC20-approve}.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function approve(address spender, uint256 amount) public virtual override returns (bool) {\n        _approve(_msgSender(), spender, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-transferFrom}.\n     *\n     * Emits an {Approval} event indicating the updated allowance. This is not\n     * required by the EIP. See the note at the beginning of {ERC20}.\n     *\n     * Requirements:\n     *\n     * - `sender` and `recipient` cannot be the zero address.\n     * - `sender` must have a balance of at least `amount`.\n     * - the caller must have allowance for ``sender``'s tokens of at least\n     * `amount`.\n     */\n    function transferFrom(\n        address sender,\n        address recipient,\n        uint256 amount\n    ) public virtual override returns (bool) {\n        _transfer(sender, recipient, amount);\n\n        uint256 currentAllowance = _allowances[sender][_msgSender()];\n        require(currentAllowance >= amount, \"ERC20: transfer amount exceeds allowance\");\n        unchecked {\n            _approve(sender, _msgSender(), currentAllowance - amount);\n        }\n\n        return true;\n    }\n\n    /**\n     * @dev Atomically increases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {\n        _approve(_msgSender(), spender, _allowances[_msgSender()][spender] + addedValue);\n        return true;\n    }\n\n    /**\n     * @dev Atomically decreases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     * - `spender` must have allowance for the caller of at least\n     * `subtractedValue`.\n     */\n    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {\n        uint256 currentAllowance = _allowances[_msgSender()][spender];\n        require(currentAllowance >= subtractedValue, \"ERC20: decreased allowance below zero\");\n        unchecked {\n            _approve(_msgSender(), spender, currentAllowance - subtractedValue);\n        }\n\n        return true;\n    }\n\n    /**\n     * @dev Moves `amount` of tokens from `sender` to `recipient`.\n     *\n     * This internal function is equivalent to {transfer}, and can be used to\n     * e.g. implement automatic token fees, slashing mechanisms, etc.\n     *\n     * Emits a {Transfer} event.\n     *\n     * Requirements:\n     *\n     * - `sender` cannot be the zero address.\n     * - `recipient` cannot be the zero address.\n     * - `sender` must have a balance of at least `amount`.\n     */\n    function _transfer(\n        address sender,\n        address recipient,\n        uint256 amount\n    ) internal virtual {\n        require(sender != address(0), \"ERC20: transfer from the zero address\");\n        require(recipient != address(0), \"ERC20: transfer to the zero address\");\n\n        _beforeTokenTransfer(sender, recipient, amount);\n\n        uint256 senderBalance = _balances[sender];\n        require(senderBalance >= amount, \"ERC20: transfer amount exceeds balance\");\n        unchecked {\n            _balances[sender] = senderBalance - amount;\n        }\n        _balances[recipient] += amount;\n\n        emit Transfer(sender, recipient, amount);\n\n        _afterTokenTransfer(sender, recipient, amount);\n    }\n\n    /** @dev Creates `amount` tokens and assigns them to `account`, increasing\n     * the total supply.\n     *\n     * Emits a {Transfer} event with `from` set to the zero address.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     */\n    function _mint(address account, uint256 amount) internal virtual {\n        require(account != address(0), \"ERC20: mint to the zero address\");\n\n        _beforeTokenTransfer(address(0), account, amount);\n\n        _totalSupply += amount;\n        _balances[account] += amount;\n        emit Transfer(address(0), account, amount);\n\n        _afterTokenTransfer(address(0), account, amount);\n    }\n\n    /**\n     * @dev Destroys `amount` tokens from `account`, reducing the\n     * total supply.\n     *\n     * Emits a {Transfer} event with `to` set to the zero address.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     * - `account` must have at least `amount` tokens.\n     */\n    function _burn(address account, uint256 amount) internal virtual {\n        require(account != address(0), \"ERC20: burn from the zero address\");\n\n        _beforeTokenTransfer(account, address(0), amount);\n\n        uint256 accountBalance = _balances[account];\n        require(accountBalance >= amount, \"ERC20: burn amount exceeds balance\");\n        unchecked {\n            _balances[account] = accountBalance - amount;\n        }\n        _totalSupply -= amount;\n\n        emit Transfer(account, address(0), amount);\n\n        _afterTokenTransfer(account, address(0), amount);\n    }\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the `owner` s tokens.\n     *\n     * This internal function is equivalent to `approve`, and can be used to\n     * e.g. set automatic allowances for certain subsystems, etc.\n     *\n     * Emits an {Approval} event.\n     *\n     * Requirements:\n     *\n     * - `owner` cannot be the zero address.\n     * - `spender` cannot be the zero address.\n     */\n    function _approve(\n        address owner,\n        address spender,\n        uint256 amount\n    ) internal virtual {\n        require(owner != address(0), \"ERC20: approve from the zero address\");\n        require(spender != address(0), \"ERC20: approve to the zero address\");\n\n        _allowances[owner][spender] = amount;\n        emit Approval(owner, spender, amount);\n    }\n\n    /**\n     * @dev Hook that is called before any transfer of tokens. This includes\n     * minting and burning.\n     *\n     * Calling conditions:\n     *\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\n     * will be transferred to `to`.\n     * - when `from` is zero, `amount` tokens will be minted for `to`.\n     * - when `to` is zero, `amount` of ``from``'s tokens will be burned.\n     * - `from` and `to` are never both zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _beforeTokenTransfer(\n        address from,\n        address to,\n        uint256 amount\n    ) internal virtual {}\n\n    /**\n     * @dev Hook that is called after any transfer of tokens. This includes\n     * minting and burning.\n     *\n     * Calling conditions:\n     *\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\n     * has been transferred to `to`.\n     * - when `from` is zero, `amount` tokens have been minted for `to`.\n     * - when `to` is zero, `amount` of ``from``'s tokens have been burned.\n     * - `from` and `to` are never both zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _afterTokenTransfer(\n        address from,\n        address to,\n        uint256 amount\n    ) internal virtual {}\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport \"../IERC20.sol\";\n\n/**\n * @dev Interface for the optional metadata functions from the ERC20 standard.\n *\n * _Available since v4.1._\n */\ninterface IERC20Metadata is IERC20 {\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() external view returns (string memory);\n\n    /**\n     * @dev Returns the symbol of the token.\n     */\n    function symbol() external view returns (string memory);\n\n    /**\n     * @dev Returns the decimals places of the token.\n     */\n    function decimals() external view returns (uint8);\n}\n"
    },
    "contracts/tests/MockERC20.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity >=0.8.0;\n\nimport {ERC20} from \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\n\ncontract MockERC20 is ERC20 {\n    constructor(string memory _name, string memory _symbol)\n        ERC20(_name, _symbol)\n    {}\n\n    function mint(address to, uint256 value) external {\n        _mint(to, value);\n    }\n\n    function burn(address from, uint256 value) external {\n        _burn(from, value);\n    }\n}\n"
    },
    "contracts/tests/MockLiquidityGauge.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity =0.8.4;\n\nimport {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport {\n    SafeERC20\n} from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\n\ncontract MockLiquidityGauge {\n    using SafeERC20 for IERC20;\n\n    address public lp_token;\n    uint256 public totalSupply;\n    mapping(address => uint256) public balanceOf;\n\n    constructor(address _lp_token) {\n        lp_token = _lp_token;\n    }\n\n    function deposit(\n        uint256 _value,\n        address _addr,\n        bool\n    ) external {\n        if (_value != 0) {\n            totalSupply += _value;\n            balanceOf[_addr] += _value;\n\n            IERC20(lp_token).safeTransferFrom(\n                msg.sender,\n                address(this),\n                _value\n            );\n        }\n    }\n}\n"
    },
    "contracts/vendor/upgrades/UpgradeabilityProxy.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity =0.8.4;\n\nimport './Proxy.sol';\nimport '@openzeppelin/contracts/utils/Address.sol';\n\n/**\n * @title UpgradeabilityProxy\n * @dev This contract implements a proxy that allows to change the\n * implementation address to which it will delegate.\n * Such a change is called an implementation upgrade.\n */\ncontract UpgradeabilityProxy is Proxy {\n  /**\n   * @dev Contract constructor.\n   * @param _logic Address of the initial implementation.\n   * @param _data Data to send as msg.data to the implementation to initialize the proxied contract.\n   * It should include the signature and the parameters of the function to be called, as described in\n   * https://solidity.readthedocs.io/en/v0.4.24/abi-spec.html#function-selector-and-argument-encoding.\n   * This parameter is optional, if no data is given the initialization call to proxied contract will be skipped.\n   */\n  constructor(address _logic, bytes memory _data) payable {\n    assert(IMPLEMENTATION_SLOT == bytes32(uint256(keccak256('eip1967.proxy.implementation')) - 1));\n    _setImplementation(_logic);\n    if(_data.length > 0) {\n      (bool success,) = _logic.delegatecall(_data);\n      require(success);\n    }\n  }\n\n  /**\n   * @dev Emitted when the implementation is upgraded.\n   * @param implementation Address of the new implementation.\n   */\n  event Upgraded(address indexed implementation);\n\n  /**\n   * @dev Storage slot with the address of the current implementation.\n   * This is the keccak-256 hash of \"eip1967.proxy.implementation\" subtracted by 1, and is\n   * validated in the constructor.\n   */\n  bytes32 internal constant IMPLEMENTATION_SLOT = 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;\n\n  /**\n   * @dev Returns the current implementation.\n   * @return impl Address of the current implementation\n   */\n  function _implementation() internal override view returns (address impl) {\n    bytes32 slot = IMPLEMENTATION_SLOT;\n    assembly {\n      impl := sload(slot)\n    }\n  }\n\n  /**\n   * @dev Upgrades the proxy to a new implementation.\n   * @param newImplementation Address of the new implementation.\n   */\n  function _upgradeTo(address newImplementation) internal {\n    _setImplementation(newImplementation);\n    emit Upgraded(newImplementation);\n  }\n\n  /**\n   * @dev Sets the implementation address of the proxy.\n   * @param newImplementation Address of the new implementation.\n   */\n  function _setImplementation(address newImplementation) internal {\n    require(Address.isContract(newImplementation), \"Cannot set a proxy implementation to a non-contract address\");\n\n    bytes32 slot = IMPLEMENTATION_SLOT;\n\n    assembly {\n      sstore(slot, newImplementation)\n    }\n  }\n}\n"
    },
    "contracts/vendor/upgrades/Proxy.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity =0.8.4;\n\n/**\n * @title Proxy\n * @dev Implements delegation of calls to other contracts, with proper\n * forwarding of return values and bubbling of failures.\n * It defines a fallback function that delegates all calls to the address\n * returned by the abstract _implementation() internal function.\n */\nabstract contract Proxy {\n  /**\n   * @dev Fallback function.\n   * Implemented entirely in `_fallback`.\n   */\n  fallback () payable external {\n    _fallback();\n  }\n\n  /**\n   * @dev Receive function.\n   * Implemented entirely in `_fallback`.\n   */\n  receive () payable external {\n    // _fallback();\n  }\n\n  /**\n   * @return The Address of the implementation.\n   */\n  function _implementation() internal virtual view returns (address);\n\n  /**\n   * @dev Delegates execution to an implementation contract.\n   * This is a low level function that doesn't return to its internal call site.\n   * It will return to the external caller whatever the implementation returns.\n   * @param implementation Address to delegate.\n   */\n  function _delegate(address implementation) internal {\n    assembly {\n      // Copy msg.data. We take full control of memory in this inline assembly\n      // block because it will not return to Solidity code. We overwrite the\n      // Solidity scratch pad at memory position 0.\n      calldatacopy(0, 0, calldatasize())\n\n      // Call the implementation.\n      // out and outsize are 0 because we don't know the size yet.\n      let result := delegatecall(gas(), implementation, 0, calldatasize(), 0, 0)\n\n      // Copy the returned data.\n      returndatacopy(0, 0, returndatasize())\n\n      switch result\n      // delegatecall returns 0 on error.\n      case 0 { revert(0, returndatasize()) }\n      default { return(0, returndatasize()) }\n    }\n  }\n\n  /**\n   * @dev Function that is run as the first thing in the fallback function.\n   * Can be redefined in derived contracts to add functionality.\n   * Redefinitions must call super._willFallback().\n   */\n  function _willFallback() internal virtual {\n  }\n\n  /**\n   * @dev fallback implementation.\n   * Extracted to enable manual triggering.\n   */\n  function _fallback() internal {\n    _willFallback();\n    _delegate(_implementation());\n  }\n}\n"
    },
    "contracts/vendor/upgrades/AdminUpgradeabilityProxy.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.8;\n\nimport './UpgradeabilityProxy.sol';\n\n/**\n * @title AdminUpgradeabilityProxy\n * @dev This contract combines an upgradeability proxy with an authorization\n * mechanism for administrative tasks.\n * All external functions in this contract must be guarded by the\n * `ifAdmin` modifier. See ethereum/solidity#3864 for a Solidity\n * feature proposal that would enable this to be done automatically.\n */\ncontract AdminUpgradeabilityProxy is UpgradeabilityProxy {\n  /**\n   * Contract constructor.\n   * @param _logic address of the initial implementation.\n   * @param admin_ Address of the proxy administrator.\n   * @param _data Data to send as msg.data to the implementation to initialize the proxied contract.\n   * It should include the signature and the parameters of the function to be called, as described in\n   * https://solidity.readthedocs.io/en/v0.4.24/abi-spec.html#function-selector-and-argument-encoding.\n   * This parameter is optional, if no data is given the initialization call to proxied contract will be skipped.\n   */\n  constructor(address _logic, address admin_, bytes memory _data) UpgradeabilityProxy(_logic, _data) payable {\n    assert(ADMIN_SLOT == bytes32(uint256(keccak256('eip1967.proxy.admin')) - 1));\n    _setAdmin(admin_);\n  }\n\n  /**\n   * @dev Emitted when the administration has been transferred.\n   * @param previousAdmin Address of the previous admin.\n   * @param newAdmin Address of the new admin.\n   */\n  event AdminChanged(address previousAdmin, address newAdmin);\n\n  /**\n   * @dev Storage slot with the admin of the contract.\n   * This is the keccak-256 hash of \"eip1967.proxy.admin\" subtracted by 1, and is\n   * validated in the constructor.\n   */\n\n  bytes32 internal constant ADMIN_SLOT = 0xb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d6103;\n\n  /**\n   * @dev Modifier to check whether the `msg.sender` is the admin.\n   * If it is, it will run the function. Otherwise, it will delegate the call\n   * to the implementation.\n   */\n  modifier ifAdmin() {\n    if (msg.sender == _admin()) {\n      _;\n    } else {\n      _fallback();\n    }\n  }\n\n  /**\n   * @return adminAddress The address of the proxy admin.\n   */\n  function admin() external ifAdmin returns (address adminAddress) {\n    return _admin();\n  }\n\n  /**\n   * @return implementationAddress The address of the implementation.\n   */\n  function implementation() external ifAdmin returns (address implementationAddress) {\n    return _implementation();\n  }\n\n  /**\n   * @dev Changes the admin of the proxy.\n   * Only the current admin can call this function.\n   * @param newAdmin Address to transfer proxy administration to.\n   */\n  function changeAdmin(address newAdmin) external ifAdmin {\n    require(newAdmin != address(0), \"Cannot change the admin of a proxy to the zero address\");\n    emit AdminChanged(_admin(), newAdmin);\n    _setAdmin(newAdmin);\n  }\n\n  /**\n   * @dev Upgrade the backing implementation of the proxy.\n   * Only the admin can call this function.\n   * @param newImplementation Address of the new implementation.\n   */\n  function upgradeTo(address newImplementation) external ifAdmin {\n    _upgradeTo(newImplementation);\n  }\n\n  /**\n   * @dev Upgrade the backing implementation of the proxy and call a function\n   * on the new implementation.\n   * This is useful to initialize the proxied contract.\n   * @param newImplementation Address of the new implementation.\n   * @param data Data to send as msg.data in the low level call.\n   * It should include the signature and the parameters of the function to be called, as described in\n   * https://solidity.readthedocs.io/en/v0.4.24/abi-spec.html#function-selector-and-argument-encoding.\n   */\n  function upgradeToAndCall(address newImplementation, bytes calldata data) payable external ifAdmin {\n    _upgradeTo(newImplementation);\n    (bool success,) = newImplementation.delegatecall(data);\n    require(success);\n  }\n\n  /**\n   * @return adm The admin slot.\n   */\n  function _admin() internal view returns (address adm) {\n    bytes32 slot = ADMIN_SLOT;\n    assembly {\n      adm := sload(slot)\n    }\n  }\n\n  /**\n   * @dev Sets the address of the proxy admin.\n   * @param newAdmin Address of the new proxy admin.\n   */\n  function _setAdmin(address newAdmin) internal {\n    bytes32 slot = ADMIN_SLOT;\n\n    assembly {\n      sstore(slot, newAdmin)\n    }\n  }\n\n  /**\n   * @dev Only fall back when the sender is not the admin.\n   */\n  function _willFallback() internal override virtual {\n    require(msg.sender != _admin(), \"Cannot call fallback function from the proxy admin\");\n    super._willFallback();\n  }\n}\n"
    },
    "contracts/interfaces/IRibbon.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity =0.8.4;\nimport {Vault} from \"../libraries/Vault.sol\";\n\ninterface IRibbonVault {\n    function deposit(uint256 amount) external;\n\n    function depositETH() external payable;\n\n    function cap() external view returns (uint256);\n\n    function depositFor(uint256 amount, address creditor) external;\n\n    function vaultParams() external view returns (Vault.VaultParams memory);\n}\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}